<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>compiler_principles/第9讲</title>
      <link href="/2020/05/08/compiler-principles/di-9-jiang/"/>
      <url>/2020/05/08/compiler-principles/di-9-jiang/</url>
      
        <content type="html"><![CDATA[<h1 id="语法分析-自上而下分析3"><a href="#语法分析-自上而下分析3" class="headerlink" title="语法分析-自上而下分析3"></a>语法分析-自上而下分析3</h1><h2 id="预测分析程序"><a href="#预测分析程序" class="headerlink" title="预测分析程序"></a>预测分析程序</h2><h5 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h5><ul><li>总控程序：根据现行栈顶符号和当前输入符号， 执行动作</li><li>分析表 M[A， a]矩阵：A ∈ V N ，a ∈ VT 是终 结符或‘＃’</li><li>分析栈 STACK 用于存放文法符号</li></ul><p><img src="%E7%AC%AC9%E8%AE%B2.assets%5Cimage-20200318224402090.png" alt="image-20200318224402090"></p><p>总控程序总是根据现行栈顶的符号和当前的输入符号来操作分析栈STACK</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p>总控程序根据当前栈顶符号X和输入符号a，执行下列三动作之一：</p><ul><li>若X＝a＝‘＃’，则宣布分析成功，停止分析</li><li>若X＝a ≠‘＃’，则把X从STACK栈顶逐出，让a指向下一个输入符号</li><li>若X是一个非终结符，则<strong>查看分析表M</strong><ul><li>若M[X，a]中存放着关于X的一个产生式，把X逐出STACK栈顶，把产生式的右部符号串按反序一一推进STACK栈(若右部符号为ε ，则意味不推什么东西进栈)</li><li>若M[X，a]中存放着“出错标志”，则调用出错诊察程序ERROR</li></ul></li></ul><h5 id="总控程序实现"><a href="#总控程序实现" class="headerlink" title="总控程序实现"></a>总控程序实现</h5><pre class="line-numbers language-text"><code class="language-text">BEGIN    首先把‘＃’然后把文法开始符号推进STACK栈；    把第一个输入符号读进a；    FLAG:=TRUE;    WHILE FLAG DO    BEGIN        把STACK栈顶符号上托出去并放在X中；        IF X∈VT THEN            IF X= a THEN 把下一输入符号读进a                   ELSE ERROR            ELSE IF X=‘#’ THEN            IF X=a THEN FLAG:=FALSE            ELSE ERROR        ELSE IF M[X,a]={X→X1X2…Xk}THEN            把Xk,Xk-1,…,X1一一推进STACK栈            /* 若X1X2…Xk=ε，不推什么进栈 */        ELSE ERROR    END OF WHILE;    STOP /*分析成功，过程完毕*/END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="预测分析例子"><a href="#预测分析例子" class="headerlink" title="预测分析例子"></a>预测分析例子</h5><p><img src="%E7%AC%AC9%E8%AE%B2.assets%5Cimage-20200319133754390.png" alt="image-20200319133754390"></p><h2 id="预测分析表的构造"><a href="#预测分析表的构造" class="headerlink" title="预测分析表的构造"></a>预测分析表的构造</h2><p>构造G的分析表M[A，a]， 确定每个产生式 A→ α在表中的位置：</p><ol><li>对文法G的每个产生式A→ α执行第2步和第3步</li><li>对每个终结符a ∈FIRST( α)，把A→ α加至M[A， a]中</li><li>若ε∈FIRST( α)，则对任何b ∈FOLLOW(A)把 A→ α加至M[A，b]中</li><li>把所有无定义的M[A，a]标上“出错标志”。</li></ol><p><img src="%E7%AC%AC9%E8%AE%B2.assets%5Cimage-20200319141252119.png" alt="image-20200319141252119"></p><h2 id="LL-1-文法与二义性"><a href="#LL-1-文法与二义性" class="headerlink" title="LL(1)文法与二义性"></a>LL(1)文法与二义性</h2><ul><li>如果G是左递归或二义的，那么，M至少含有一个多重定义入口。因此，消除左递归和提取左因子将有助于获得无多重定义的分析表M</li><li>可以证明，一个文法G的预测分析表M不含多重定义入口，当且仅当该文法为LL(1)的</li><li><strong>LL(1)文法不是二义的</strong></li></ul><p><img src="%E7%AC%AC9%E8%AE%B2.assets%5Cimage-20200319143358188.png" alt="image-20200319143358188"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>compiler_principles/第7讲</title>
      <link href="/2020/05/08/compiler-principles/di-7-jiang/"/>
      <url>/2020/05/08/compiler-principles/di-7-jiang/</url>
      
        <content type="html"><![CDATA[<h1 id="语法分析-自上而下分析1"><a href="#语法分析-自上而下分析1" class="headerlink" title="语法分析-自上而下分析1"></a>语法分析-自上而下分析1</h1><h2 id="自上而下分析的基本问题"><a href="#自上而下分析的基本问题" class="headerlink" title="自上而下分析的基本问题"></a>自上而下分析的基本问题</h2><h4 id="语法分析的任务"><a href="#语法分析的任务" class="headerlink" title="语法分析的任务"></a>语法分析的任务</h4><ul><li>分析一个文法的句子结构</li></ul><h4 id="语法分析器的功能"><a href="#语法分析器的功能" class="headerlink" title="语法分析器的功能"></a>语法分析器的功能</h4><ul><li>按照文法的产生式（语言的语法规则），识别输入符号串是否为一个句子（合式程序）</li></ul><h4 id="语法分析器在编译器中的地位"><a href="#语法分析器在编译器中的地位" class="headerlink" title="语法分析器在编译器中的地位"></a>语法分析器在编译器中的地位</h4><p><img src="%E7%AC%AC7%E8%AE%B2.assets%5Cimage-20200315165955316.png" alt="image-20200315165955316"></p><h4 id="语法分析的方法"><a href="#语法分析的方法" class="headerlink" title="语法分析的方法"></a>语法分析的方法</h4><h5 id="自下而上（Bottom-up）"><a href="#自下而上（Bottom-up）" class="headerlink" title="自下而上（Bottom-up）"></a>自下而上（Bottom-up）</h5><ul><li><p>从输入串开始，逐步进行归约，直到文法的开始符号</p></li><li><p>根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号</p></li><li><p>从<strong>树叶节点</strong>开始，构造语法树</p></li><li><p>算符优先分析法、LR分析法</p></li></ul><h5 id="自上而下（Top-down）"><a href="#自上而下（Top-down）" class="headerlink" title="自上而下（Top-down）"></a>自上而下（Top-down）</h5><ul><li>从文法的开始符号出发， 反复使用各种产生式，寻找”匹配”的推导</li><li>推导：根据文法的产生式 规则，把串中出现的产生式的左部符号替换成右部</li><li>从树的根开始，构造语法树</li><li>递归下降分析法、预测分析程序</li></ul><h4 id="自上而下分析面临的问题"><a href="#自上而下分析面临的问题" class="headerlink" title="自上而下分析面临的问题"></a>自上而下分析面临的问题</h4><p><img src="%E7%AC%AC7%E8%AE%B2.assets%5Cimage-20200315211034207.png" alt="image-20200315211034207"></p><h5 id="回溯问题"><a href="#回溯问题" class="headerlink" title="回溯问题"></a>回溯问题</h5><ul><li>分析过程中，当一个非终结符用某一个候选匹配成功时，这种匹配可能是暂时的</li><li>出错时，不得不“回溯”</li></ul><h5 id="文法左递归问题"><a href="#文法左递归问题" class="headerlink" title="文法左递归问题"></a>文法左递归问题</h5><p><img src="%E7%AC%AC7%E8%AE%B2.assets%5Cimage-20200315211439235.png" alt="image-20200315211439235"></p><ul><li>一个文法是含有左递归的，如果存在非终结符P</li></ul><h2 id="LL-1-文法-消除左递归"><a href="#LL-1-文法-消除左递归" class="headerlink" title="LL(1)文法-消除左递归"></a>LL(1)文法-消除左递归</h2><h4 id="消除直接左递归"><a href="#消除直接左递归" class="headerlink" title="消除直接左递归"></a>消除直接左递归</h4><p>左递归转换为右递归，使得处理的单词能够一直推进，直到最后的非终结符，相比于左递归，不会在一开始就出现无限递归的情况（导致后续单词无法解析）</p><ul><li>假定P关于的全部产生式是</li></ul><p>$$<br>p \to P\alpha_1 | P\alpha_2 | … | P\alpha_m | \beta_1 | \beta_2 | … | \beta_n<br>$$</p><p>(每个 α都不等于 ε，每个 β都不以P开头)</p><p><img src="%E7%AC%AC7%E8%AE%B2.assets%5Cimage-20200315213315489.png" alt="image-20200315213315489"></p><p>例：</p><p><img src="%E7%AC%AC7%E8%AE%B2.assets%5Cimage-20200315224604783.png" alt="image-20200315224604783"></p><h4 id="消除间接左递归"><a href="#消除间接左递归" class="headerlink" title="消除间接左递归"></a>消除间接左递归</h4><ul><li>一个文法消除左递归的条件<ul><li>不含以 ε为右部的产生式</li><li>不含回路 （P =&gt; P）</li></ul></li></ul><p><img src="%E7%AC%AC7%E8%AE%B2.assets%5Cimage-20200316143951616.png" alt="image-20200316143951616"></p><h4 id="消除左递归的算法"><a href="#消除左递归的算法" class="headerlink" title="消除左递归的算法"></a>消除左递归的算法</h4><p><img src="%E7%AC%AC7%E8%AE%B2.assets%5Cimage-20200316152048032.png" alt="image-20200316152048032"></p><p>例：</p><p><img src="%E7%AC%AC7%E8%AE%B2.assets%5Cimage-20200316152234717.png" alt="image-20200316152234717"></p><p>由于从S出发到达S’，S’出发还是到达S’，所以Q和R没用，定义时多余的，可以删除</p><p><img src="%E7%AC%AC7%E8%AE%B2.assets%5Cimage-20200316152446994.png" alt="image-20200316152446994"></p><h2 id="LL-1-文法-消除回溯"><a href="#LL-1-文法-消除回溯" class="headerlink" title="LL(1)文法-消除回溯"></a>LL(1)文法-消除回溯</h2><p><strong>为了消除回溯必须保证：</strong></p><ul><li>对文法的任何非终结符，当要它去匹配输入串时，能够根据它所面临的输入符号准确地指派它的一个候选去执行任务，并且此候选的工作结果应是确信无疑的</li></ul><p><strong>对于当前读入的一个符号a，在非终结符A的所有候选当中，准确地指派一个候选，去扩展A，使得最后一定能够分析成功（句子分析成功或是读入的不是句子）</strong></p><h4 id="FIRST集合"><a href="#FIRST集合" class="headerlink" title="FIRST集合"></a>FIRST集合</h4><p>令G是一个不含左递归的文法，对G的所有非终结符的每个候选α定义它的终结首符集FIRST(α) 为：<br>$$<br>FIRST(\alpha) = {a | \alpha =&gt; a … , a \in V_T}<br>$$<br>如果非终结符A的所有候选首符集两两不相交，即A的任何两个不同候选α<del>i</del>和α<del>j</del><br>$$<br>FIRST(\alpha_i) \cap FIRST(\alpha_j) = \empty<br>$$<br>当要求A匹配输入串时，A能根据它所面临的第一个输入符号a，准确地指派某一个候选去执行任务。这个候选就是那个终结首符集含a的α</p><p>例：</p><p><img src="%E7%AC%AC7%E8%AE%B2.assets%5Cimage-20200316192005200.png" alt="image-20200316192005200"></p><h5 id="提取公共左因子"><a href="#提取公共左因子" class="headerlink" title="提取公共左因子"></a>提取公共左因子</h5><p><img src="%E7%AC%AC7%E8%AE%B2.assets%5Cimage-20200316191229572.png" alt="image-20200316191229572"></p><h4 id="FOLLOW集合"><a href="#FOLLOW集合" class="headerlink" title="FOLLOW集合"></a>FOLLOW集合</h4><p><img src="%E7%AC%AC7%E8%AE%B2.assets%5Cimage-20200316193550925.png" alt="image-20200316193550925"></p><h2 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h2><h4 id="LL-1-文法条件"><a href="#LL-1-文法条件" class="headerlink" title="LL(1)文法条件"></a>LL(1)文法条件</h4><ul><li><p>构造不带回溯的自上而下分析的文法条件</p><ol><li><p>文法不含左递归</p></li><li><p>对于文法中每一个非终结符A的各个产生式的候选首符集两两不相交。即，若</p><p>$$A \to \alpha_1 | \alpha_2 | \alpha_3 | … | \alpha_n$$</p><p>则 $$FIRST(\alpha_i) \cap FIRST(\alpha_j) = \empty$$</p></li></ol></li></ul><pre><code>3.  对文法中的每个非终结符A，若它存在某个候选首符集包含ε，则  $$FIRST(\alpha_i) \cap FOLLOW(A) = \empty, i = 1, 2, ..., n$$</code></pre><p>如果一个文法G满足以上条件，则称该文法G为<strong>LL(1)</strong>（第一个L指从左向右推导，第二个L指最左推导，1指每一步只向前查看一个符号）</p><h4 id="LL-1-分析"><a href="#LL-1-分析" class="headerlink" title="LL(1)分析"></a>LL(1)分析</h4><ol><li>假设要用非终结符A进行匹配，面临的输入符号为a，A 的所有产生式为$$A\to\alpha_1|\alpha_2|…|\alpha_n$$<ul><li>若$$a\in FIRST(\alpha_i)$$，则指派α<del>i</del>执行匹配任务；</li><li>若a不属于任何一个候选首符集，则<ul><li>若ε属于某个FIRST(α<del>i</del>)且 $$a\in FOLLOW(A)$$， 则让 A与ε自动匹配</li><li>否则，a的出现是一种语法错误</li></ul></li></ul></li></ol><h2 id="FIRST和FOLLOW集合的构造"><a href="#FIRST和FOLLOW集合的构造" class="headerlink" title="FIRST和FOLLOW集合的构造"></a>FIRST和FOLLOW集合的构造</h2><h4 id="FIRST集合的构造"><a href="#FIRST集合的构造" class="headerlink" title="FIRST集合的构造"></a>FIRST集合的构造</h4><p><img src="%E7%AC%AC7%E8%AE%B2.assets%5Cimage-20200321222107014.png" alt="image-20200321222107014"></p><h4 id="FOLLOW集合的构造"><a href="#FOLLOW集合的构造" class="headerlink" title="FOLLOW集合的构造"></a>FOLLOW集合的构造</h4><p><img src="%E7%AC%AC7%E8%AE%B2.assets%5Cimage-20200321222132139.png" alt="image-20200321222132139"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>compiler_principles/第8讲</title>
      <link href="/2020/05/08/compiler-principles/di-8-jiang/"/>
      <url>/2020/05/08/compiler-principles/di-8-jiang/</url>
      
        <content type="html"><![CDATA[<h1 id="语法分析-自上而下分析2"><a href="#语法分析-自上而下分析2" class="headerlink" title="语法分析-自上而下分析2"></a>语法分析-自上而下分析2</h1><h2 id="构造递归下降分析器"><a href="#构造递归下降分析器" class="headerlink" title="构造递归下降分析器"></a>构造递归下降分析器</h2><h4 id="递归下降分析器"><a href="#递归下降分析器" class="headerlink" title="递归下降分析器"></a>递归下降分析器</h4><ul><li>分析程序由一组子程序组成， 对每一<strong>语法单位(非终结符)</strong>构造一个相应的子程序，识别对应的语法单位</li><li>通过子程序间的相互调用实现对输入串的识别，如 A → BcD<ul><li>子程序A调用子程序B识别B，若碰到D则调用子程序D进行识别</li></ul></li><li>文法的定义通常是递归的，通常具有递归结构</li></ul><h4 id="递归下降子程序设计"><a href="#递归下降子程序设计" class="headerlink" title="递归下降子程序设计"></a>递归下降子程序设计</h4><ul><li>定义全局过程和变量<ul><li>ADVANCE，把输入串指示器IP指向下一个输入符号，即读入一个单词符号</li><li>SYM，IP当前所指的输入符号</li><li>ERROR，出错处理子程序</li></ul></li></ul><p><img src="%E7%AC%AC8%E8%AE%B2.assets%5Cimage-20200318184900365.png" alt="image-20200318184900365"></p><p><img src="%E7%AC%AC8%E8%AE%B2.assets%5Cimage-20200318190438647.png" alt="image-20200318190438647"></p><p>上述两种E’的实现方式是等价的，什么都不做E’返回了，相当于E’得到正确的执行，即E’扩展成了ε</p><p><strong>不考虑Follow集合没有问题</strong>：会被后续执行的子程序检查出来并报错（在检查候选的FIRST集合时发现这类遗留的错误）</p><p><img src="%E7%AC%AC8%E8%AE%B2.assets%5Cimage-20200318192826102.png" alt="image-20200318192826102"></p><h2 id="扩充的巴科斯范式"><a href="#扩充的巴科斯范式" class="headerlink" title="扩充的巴科斯范式"></a>扩充的巴科斯范式</h2><p>在元符号“→”或“::=”和“|”的基础上，扩 充几个元语言符号：</p><ul><li>用花括号{ α}表示闭包运算 α*</li><li>用表示{ α } 0 n可任意重复0次至n次</li><li>用方括号[ α]表示{ α } 0 1，即表示 α的出现可有可无(等 价于 α|ε)</li></ul><p>例如，通常的“实数”可定义为：</p><ul><li>Decimal→[Sign]Integer.{digit}[Exponent]</li><li>Exponent→E[Sign]Integer</li><li>Integer→digit{digit}</li><li>Sign→ + | -</li></ul><p><strong>用扩充的巴科斯范式来描述语法，直观易懂， 便于表示左递归消去和因子提取</strong></p><p><img src="%E7%AC%AC8%E8%AE%B2.assets%5Cimage-20200318193810545.png" alt="image-20200318193810545"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>compiler_principles/第6讲</title>
      <link href="/2020/05/08/compiler-principles/di-6-jiang/"/>
      <url>/2020/05/08/compiler-principles/di-6-jiang/</url>
      
        <content type="html"><![CDATA[<h2 id="6-1-有限自动机的等价性"><a href="#6-1-有限自动机的等价性" class="headerlink" title="6.1 有限自动机的等价性"></a>6.1 有限自动机的等价性</h2><h4 id="DFA与NFA的等价性证明思路"><a href="#DFA与NFA的等价性证明思路" class="headerlink" title="DFA与NFA的等价性证明思路"></a>DFA与NFA的等价性证明思路</h4><p>二者差别：</p><table><thead><tr><th></th><th>NFA</th><th>DFA</th></tr></thead><tbody><tr><td>初始状态</td><td>不唯一</td><td>唯一</td></tr><tr><td>弧上的标记</td><td>字（单字字符、ε）</td><td>字符</td></tr><tr><td>转换关系</td><td>非确定</td><td>确定</td></tr></tbody></table><p><strong>如果能够消除二者在初始状态，在弧上的标记以及在转换关系上这三方面的差别，就能够把NFA变换成DFA</strong></p><h4 id="DFA与NFA的等价性证明"><a href="#DFA与NFA的等价性证明" class="headerlink" title="DFA与NFA的等价性证明"></a>DFA与NFA的等价性证明</h4><p>假定NFA M=&lt;S,Σ,δ, S<del>0</del>, F&gt;，我们对M的状 态转换图进行以下改造：</p><h5 id="解决初始状态唯一性"><a href="#解决初始状态唯一性" class="headerlink" title="解决初始状态唯一性"></a>解决初始状态唯一性</h5><ul><li>引进新的初态结点X和终态结点Y，X,Y ∉S，从X到S<del>0</del>中任意状态结点连一条ε箭弧， 从F中任意状态结点连一条 ε箭弧到Y</li></ul><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200307183141018.png" alt="image-20200307183141018"></p><h5 id="简化弧上的标记"><a href="#简化弧上的标记" class="headerlink" title="简化弧上的标记"></a>简化弧上的标记</h5><ul><li>对M的状态转换图进一步施行替换，其中k是新引入的状态</li></ul><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200307183303977.png" alt="image-20200307183303977"></p><ul><li>逐步把图转变为每条弧只标记为 Σ上的一个字符或 ε，最后得到一个NFA M’，显然 L(M’)=L(M)</li></ul><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200307183610945.png" alt="image-20200307183610945"></p><h5 id="解决ε弧和转换关系"><a href="#解决ε弧和转换关系" class="headerlink" title="解决ε弧和转换关系"></a>解决ε弧和转换关系</h5><p><strong>NFA确定化–子集法</strong></p><h6 id="解决ε弧"><a href="#解决ε弧" class="headerlink" title="解决ε弧"></a>解决ε弧</h6><p>设I是的状态集的一个子集，定义I的 ε-闭包 <code>ε-closure(I)</code>为:</p><ul><li>若s ∈I，则<code>s∈ε-closure(I)</code>；</li><li>若s ∈I，则从s出发经过<strong>任意</strong>条ε弧而能到达的任何状态s’都属于 <code>ε-closure(I)</code></li></ul><p>即<br>$$<br>ε-closure(I)=I ∪{s’|从某个s ∈I出发经过任意条 ε 弧能到达s’}<br>$$</p><p>设a是 Σ中的一个字符，定义<br>$$<br>I_a = ε-closure(J)<br>$$<br>其中，J为I中的某个状态出发经过一条a弧而到达的状态集合</p><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200307210803068.png" alt="image-20200307210803068"></p><p>例：</p><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200307215358059.png" alt="image-20200307215358059"></p><h6 id="确定化"><a href="#确定化" class="headerlink" title="确定化"></a>确定化</h6><p>不失一般性，设字母表只包含两个a 和 b，构造一张计算状态集的转换表：</p><ol><li>首先，置第 1行第 1列为 ε - closure({X})求出这一列的I<del>a</del>，I<del>b</del></li><li>检查这两个I<del>a</del>，I<del>b</del>，看它们是否已在表中的第一列中出现，把未曾出现的填入后面的空行的第 1列上，求出每行第 2， 3列上的集合…</li><li>重复上述过程，直到所有第 2，3列子集全部出现在第一列为止</li></ol><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200307232209075.png" alt="image-20200307232209075"></p><h5 id="状态转换关系表推算样例"><a href="#状态转换关系表推算样例" class="headerlink" title="状态转换关系表推算样例"></a>状态转换关系表推算样例</h5><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200307233656083.png" alt="image-20200307233656083"></p><ul><li>把表看成状态转换矩阵，子集视为状态</li><li>转换表唯一刻划了一个确定 的有限自动机M<ul><li><code>初态</code> 是 ε-closure({X})</li><li><code>终态</code>是含有原终态Y的子集</li></ul></li><li>对于每个NFA M存在一个 DFA M ’ ，使得 L(M)=L(M’)</li></ul><p>最终结果：</p><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200307234407769.png" alt="image-20200307234407769"></p><h4 id="DFA的化简"><a href="#DFA的化简" class="headerlink" title="DFA的化简"></a>DFA的化简</h4><blockquote><p>对于给定的DFA M，寻找一个状态数比M少的DFA M’，使得L(M)=L(M’)</p></blockquote><ul><li>状态的等价性<ul><li>假设s和t为M的两个状态，称s和t<strong>等价</strong>：如果从状态 s出发能读出某个字 α而停止于<strong>终态</strong>，那么同样，从t 出发也能读出 α而停止于<strong>终态</strong>；反之亦然（s和t到达的终态可以不一样但必须得是终态）</li><li>两个状态不等价，则称它们是可区别的</li></ul></li></ul><p>两个状态s和t是可区分的，是指：</p><p><strong><code>存在</code>一个字 α，要么s读出 α停止于终态而t读出 α停止于非终态，要么t读出 α停止于终态而s读 出 α停止于非终态</strong></p><h5 id="化简的基本思想"><a href="#化简的基本思想" class="headerlink" title="化简的基本思想"></a>化简的基本思想</h5><ul><li>把M的状态集划分为一些不相交的子集，使得任何两个不同子集的状态是可区别的，而同一子集的任何两个状态是等价的</li><li>最后，让每个子集选出一个代表，同时消去其他状态</li></ul><p><strong>按照上述原则对DFA的状态集合S进行第一次划分，正确的分法是：<code>终态和非终态</code></strong></p><blockquote><p>可区别：存在一个字 α，要么 s读出 α停止于终态而 t读出 α 停 止于非终态，要么 t读出 α停止于终态而 s读出 α停止于非终态</p></blockquote><p><strong>归根结底，需要找到一个字，把状态集区分开来，而 <code>ε</code> 可以把终态与非终态区分开来（终态经过ε依然在终态，而非终态经过ε依然处于非终态）</strong></p><h4 id="DFA化简算法"><a href="#DFA化简算法" class="headerlink" title="DFA化简算法"></a>DFA化简算法</h4><p> <img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200308155035199.png" alt="image-20200308155035199"></p><h2 id="6-2-正规式与有限自动机的等价性"><a href="#6-2-正规式与有限自动机的等价性" class="headerlink" title="6.2 正规式与有限自动机的等价性"></a>6.2 正规式与有限自动机的等价性</h2><h4 id="正规式与有限自动机的等价性"><a href="#正规式与有限自动机的等价性" class="headerlink" title="正规式与有限自动机的等价性"></a>正规式与有限自动机的等价性</h4><ul><li>一个正规式r与一个有限自动机M等价<ul><li>L(r)=L(M)</li></ul></li><li>FA -&gt;正规式<ul><li>对任何FA M，都存在一个正规式r，使得L(r)=L(M)</li></ul></li><li>正规式 -&gt; FA<ul><li>对任何正规式r，都存在一个FA M，使得L(M)=L(r)</li></ul></li></ul><h4 id="为NFA构造正规式"><a href="#为NFA构造正规式" class="headerlink" title="为NFA构造正规式"></a>为NFA构造正规式</h4><p>假定NFA M=&lt;S,Σ,δ, S<del>0</del>, F&gt;，我们对M的状态转换图进行以下改造：</p><ul><li>在M的转换图上加进两个状态X和Y，从X用 ε弧连接到M的所有初态结点，从M的所有终态结点用 ε弧连接到Y</li><li>然后，反复使用下面的三条规则，逐步消去结点， 直到只剩下X和Y为止</li></ul><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200308171844080.png" alt="image-20200308171844080"></p><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200308205920564.png" alt="image-20200308205920564"></p><ul><li><strong>对任何FA M，都存在一个正规式r，使得L(r)=L(M)</strong></li></ul><h4 id="为正规式构造NFA"><a href="#为正规式构造NFA" class="headerlink" title="为正规式构造NFA"></a>为正规式构造NFA</h4><p>对给定正规式r中的运算符数目进行归纳（归纳法）：</p><ul><li>验证r中的运算符数目为0时，结论成立</li><li>假设结论对于运算符数目少于k(k ≥1)的正规式成立</li><li>基于该假设，证明结论对于运算符数目为k的正规式成立</li></ul><ol><li>若r具有零个运算符，则r= ε 或r= φ 或r=a，其中 a∈Σ，针对上述3类正规式r，分别按照下图构造NFA M，M只有一个初态和一个终态，而且没有从终态出发的箭弧，而且使L(M)和对应的L(r)相等</li></ol><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200308214257087.png" alt="image-20200308214257087"></p><ol start="2"><li>假设对于运算符数目少于k(k ≥1) 的正规式成立</li></ol><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200308234846121.png" alt="image-20200308234846121"></p><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200308234856521.png" alt="image-20200308234856521"></p><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200308234907737.png" alt="image-20200308234907737"></p><h4 id="由正规式构造DFA示例"><a href="#由正规式构造DFA示例" class="headerlink" title="由正规式构造DFA示例"></a>由正规式构造DFA示例</h4><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200309000326351.png" alt="image-20200309000326351"></p><h2 id="6-3-词法分析程序自动生成"><a href="#6-3-词法分析程序自动生成" class="headerlink" title="6.3 词法分析程序自动生成"></a>6.3 词法分析程序自动生成</h2><h4 id="词法分析器的自动产生–LEX"><a href="#词法分析器的自动产生–LEX" class="headerlink" title="词法分析器的自动产生–LEX"></a>词法分析器的自动产生–LEX</h4><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200309002138905.png" alt="image-20200309002138905"></p><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200309003237097.png" alt="image-20200309003237097"></p><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200309003514036.png" alt="image-20200309003514036"></p><ul><li><p><code>辅助定义</code>：以文法形式，给一些常用的正规式进行命名</p></li><li><p><code>识别规则</code>：多条词法分析规则，每一个规则都要返回单词对应的种类编码及对应的值</p></li></ul><h5 id="LEX工作过程"><a href="#LEX工作过程" class="headerlink" title="LEX工作过程"></a>LEX工作过程</h5><p><img src="%E7%AC%AC6%E8%AE%B2.assets%5Cimage-20200309004110313.png" alt="image-20200309004110313"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>compiler_principles/第4讲</title>
      <link href="/2020/05/08/compiler-principles/di-4-jiang/"/>
      <url>/2020/05/08/compiler-principles/di-4-jiang/</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-词法分析概述"><a href="#4-1-词法分析概述" class="headerlink" title="4.1 词法分析概述"></a>4.1 词法分析概述</h2><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><ul><li><p>词法分析器的设计</p></li><li><p>正规表达式与有限自动机</p></li><li><p>词法分析器的自动产生–LEX</p></li></ul><h5 id="词法分析的任务"><a href="#词法分析的任务" class="headerlink" title="词法分析的任务"></a>词法分析的任务</h5><blockquote><p>从左至右逐个字符地对源程序进行扫描，产生一个个单词符号</p></blockquote><ul><li>词法分析器(Lexical Analyzer)<ul><li>扫描器(Scanner)</li><li>执行词法分析的程序</li></ul></li></ul><h5 id="词法分析器的功能"><a href="#词法分析器的功能" class="headerlink" title="词法分析器的功能"></a>词法分析器的功能</h5><blockquote><p>输入源程序，输出单词符号</p></blockquote><ul><li>单词符号种类<ul><li>基本字：如 begin，repeat，for， …</li><li>标识符：用来表示各种名字，如变量名、数组名和过程名</li><li>常数：各种类型的常数</li><li>运算符：+，-，*，/， …</li><li>界符：逗号、分号、括号和空白</li></ul></li></ul><h5 id="词法分析器的输出"><a href="#词法分析器的输出" class="headerlink" title="词法分析器的输出"></a>词法分析器的输出</h5><ul><li>输出的单词符号的表示形式（一个二元组）：<strong>(单词种别，单词自身的值 )</strong></li><li>单词种别通常用整数编码表示<ul><li>若一个种别只有一个单词符号，则种别编码就代表该单词符号。假定基本字 、运算符和界符都是一符一种</li><li>若一个种别有多个单词符号，则对于每个单词符号，给出种别编码和自身的值<ul><li>标识符单列一种；标识符自身的值表示成按机器字节划分的内部码</li><li>常数按类型分种；常数的值则表示成标准的二进制形式</li></ul></li></ul></li></ul><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200305204957424.png" alt="image-20200305204957424"></p><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200305205006022.png" alt="image-20200305205006022"></p><h5 id="词法分析器在编译器中的地位"><a href="#词法分析器在编译器中的地位" class="headerlink" title="词法分析器在编译器中的地位"></a>词法分析器在编译器中的地位</h5><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200305213155855.png" alt="image-20200305213155855"></p><ul><li>词法分析器和语法分析器都会在符号表中记录访问，修改编译过程各类信息</li><li>分模块相互调用提高了系统的利用率</li></ul><h2 id="4-2-词法分析器的设计"><a href="#4-2-词法分析器的设计" class="headerlink" title="4.2 词法分析器的设计"></a>4.2 词法分析器的设计</h2><h4 id="词法分析器的结构"><a href="#词法分析器的结构" class="headerlink" title="词法分析器的结构"></a>词法分析器的结构</h4><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200305214422322.png" alt="image-20200305214422322"></p><ol><li><p>预处理子程序在扫描器的调用下，将源程序输入到输入缓冲区中，读入输入缓冲区的字符，进行文本的预处理</p></li><li><p>进行预处理后，规范性更好的文本被送入扫描缓冲区中</p></li><li><p>预处理子程序返回扫描器，扫描器继续从缓冲区中读取预处理后的文本，根据词法规则识别出单词的符号</p></li></ol><h5 id="扫描缓冲区"><a href="#扫描缓冲区" class="headerlink" title="扫描缓冲区"></a>扫描缓冲区</h5><blockquote><p>两个半区互补使用，防止一个单词的扫描被打断</p></blockquote><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200305221130549.png" alt="image-20200305221130549"></p><p><strong>半区的长度就是一个单词所允许的最大长度</strong></p><p>某些语言规定标识符的长度不能超过某个t值，可以推断编译器的扫描缓冲区长度为2t</p><h4 id="超前搜索"><a href="#超前搜索" class="headerlink" title="超前搜索"></a>超前搜索</h4><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200305233628880.png" alt="image-20200305233628880"></p><ul><li><p>标识符识别</p><ul><li>字母开头的字母数字串，后跟界符或算符</li></ul></li><li><p>常数识别</p><ul><li><p>识别出算术常数并将其转变为二进制内码表示</p><ul><li>5.EQ.M（测试5和变量是否相等）</li><li>5.E08（5*10^8^的科学计数表示）</li></ul></li><li><p>算符和界符的识别</p><ul><li><p>把多字符组成的算符和界符拼合成一个单词符号</p><p>  <code>:=， **， .EQ. ， ++，--，&gt;=</code></p></li></ul></li></ul></li></ul><h5 id="几点限制——不必使用超前搜索"><a href="#几点限制——不必使用超前搜索" class="headerlink" title="几点限制——不必使用超前搜索"></a>几点限制——不必使用超前搜索</h5><ul><li>所有基本字都是保留字;用户不能用它们作自己的标识符</li><li>基本字作为特殊的标识符来处理，使用保留字表</li><li>如果基本字、标识符和常数(或标号)之间没有确定的运算符或界符作间隔，则必须使用一个空白符作间隔<ul><li>如 <code>DO99K=1，10</code> 要写成 <code>DO 99 K=1，10</code></li></ul></li></ul><h4 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h4><blockquote><p>状态转换图是一张有限方向图</p></blockquote><ul><li>结点代表<code>状态</code>，用圆圈表示</li><li><code>状态</code>之间用箭弧连结，箭弧上的标记(字符)代表射出结状态下可能出现的输入<code>字符</code>或<code>字符类</code>（箭头上的标记表示输入此标记后状态转换）</li><li>一张转换图只包含<code>有限个状态</code>，其中有一个为<code>初态</code>， 至少要有一个<code>终态</code>（用双圈表示）</li></ul><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200305235938616.png" alt="image-20200305235938616"></p><blockquote><p>状态转换图可用于识别(或接受)一定的字符串</p></blockquote><ul><li>若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于α，则称α被该状态转换图所识别(接受)（最后读入的字符不属于当前识别的字符串）</li></ul><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200306000755729.png" alt="image-20200306000755729"></p><p><strong>*号表示最后面读入的字符不属于刚才读入的单词</strong></p><p>以下则是识别标识符的状态转换图：</p><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200306001126007.png" alt="image-20200306001126007"></p><h5 id="词法分析器设计示例"><a href="#词法分析器设计示例" class="headerlink" title="词法分析器设计示例"></a>词法分析器设计示例</h5><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200306111428825.png" alt="image-20200306111428825"></p><ul><li>状态0识别单词前的空白符</li><li>0 -&gt; 13 是出错处理</li></ul><h4 id="状态转换图的实现"><a href="#状态转换图的实现" class="headerlink" title="状态转换图的实现"></a>状态转换图的实现</h4><h5 id="不含回路的状态结点"><a href="#不含回路的状态结点" class="headerlink" title="不含回路的状态结点"></a>不含回路的状态结点</h5><ul><li>可用一个<code>CASE</code>语句或一组<code>IF-THEN-ELSE</code>语句实现</li></ul><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200306113509712.png" alt="image-20200306113509712"></p><h5 id="含回路的状态结点"><a href="#含回路的状态结点" class="headerlink" title="含回路的状态结点"></a>含回路的状态结点</h5><ul><li>对应一段由<code>WHILE</code>结构和<code>IF</code>语句构成的程序</li></ul><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200306113537952.png" alt="image-20200306113537952"></p><h5 id="终态结点"><a href="#终态结点" class="headerlink" title="终态结点"></a>终态结点</h5><ul><li>表示识别出某种单词符号，对应返回语句</li></ul><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200306114751041.png" alt="image-20200306114751041"></p><h5 id="全局变量与过程"><a href="#全局变量与过程" class="headerlink" title="全局变量与过程"></a>全局变量与过程</h5><h5 id="词法分析器的实现"><a href="#词法分析器的实现" class="headerlink" title="词法分析器的实现"></a>词法分析器的实现</h5><h6 id="识别标识符"><a href="#识别标识符" class="headerlink" title="识别标识符"></a>识别标识符</h6><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200306120105948.png" alt="image-20200306120105948"></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> code<span class="token punctuation">,</span> value<span class="token punctuation">;</span> strToken <span class="token punctuation">:</span><span class="token operator">=</span> “ ”<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*置strToken为空串*/</span><span class="token function">GetChar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">GetBC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//跳过空白</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsLetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>begin     <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">IsLetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> or <span class="token function">IsDigit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     begin         <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果为字母或数字则连接到strToken中</span>        <span class="token function">GetChar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    end    <span class="token function">Retract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 最后读入的字符回退回去</span>    code <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token function">Reserve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 拿strToken中的字符串查询保留字表，如果是保留字，返回种别编码，否则就是用户自定义的标识符，返回0</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>code <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 判断为用户自定义的标识符</span>    begin         value <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token function">InsertId</span><span class="token punctuation">(</span>strToken<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将其插入到符号表中并返回入口值</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>$ID<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回种别编码及对应的入口值</span>    end    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>code<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接返回保留字的种别编码，无值</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="识别整常数"><a href="#识别整常数" class="headerlink" title="识别整常数"></a>识别整常数</h6><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200306120145223.png" alt="image-20200306120145223"></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsDigit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>begin    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">IsDigit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    begin        <span class="token function">Concat</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 如果为数字则连接到strToken中</span>        <span class="token function">GetChar</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    end    <span class="token function">Retract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 最后读入的字符回退回去</span>    value <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token function">InsertConst</span><span class="token punctuation">(</span>strToken<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>$INT<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>end<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">=</span>‘<span class="token operator">=</span>’<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>$ASSIGN<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">=</span>‘<span class="token operator">+</span>’<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>$PLUS<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="识别其它字符"><a href="#识别其它字符" class="headerlink" title="识别其它字符"></a>识别其它字符</h6><p><img src="%E7%AC%AC4%E8%AE%B2.assets%5Cimage-20200306120208499.png" alt="image-20200306120208499"></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">=</span>‘<span class="token operator">*</span>’<span class="token punctuation">)</span>begin    <span class="token function">GetChar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">=</span>‘<span class="token operator">*</span>’<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>$POWER<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 乘方符号判断</span>    <span class="token function">Retract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>$STAR<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">)</span><span class="token punctuation">;</span>end<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">=</span>‘<span class="token punctuation">,</span>’<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>$COMMA<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">=</span>‘<span class="token punctuation">(</span>’<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>$LPAR<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">=</span>‘<span class="token punctuation">)</span>’<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>$RPAR<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token function">ProcError</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 错误处理*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="状态转换图的代码一般化"><a href="#状态转换图的代码一般化" class="headerlink" title="状态转换图的代码一般化"></a>状态转换图的代码一般化</h5><ul><li><p>变量<code>curState</code>用于保存现有的状态</p></li><li><p>用二维数组表示状态图：<code>stateTrans[state][ch]</code></p></li></ul><pre class="line-numbers language-c"><code class="language-c">curState <span class="token operator">=</span> 初态<span class="token function">GetChar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>stateTrans<span class="token punctuation">[</span>curState<span class="token punctuation">]</span><span class="token punctuation">[</span>ch<span class="token punctuation">]</span>有定义<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//存在后继状态，读入、拼接</span>    <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//转换入下一状态，读入下一字符</span>    curState<span class="token operator">=</span> stateTrans<span class="token punctuation">[</span>curState<span class="token punctuation">]</span><span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> curState是终态 then 返回strToken中的单词    <span class="token function">GetChar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>compiler_principles/第5讲</title>
      <link href="/2020/05/08/compiler-principles/di-5-jiang/"/>
      <url>/2020/05/08/compiler-principles/di-5-jiang/</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-词法规则形式化-正规集与正规式"><a href="#5-1-词法规则形式化-正规集与正规式" class="headerlink" title="5.1 词法规则形式化-正规集与正规式"></a>5.1 词法规则形式化-正规集与正规式</h2><h4 id="正规式和正规集"><a href="#正规式和正规集" class="headerlink" title="正规式和正规集"></a>正规式和正规集</h4><p><strong>程序语言定义的合法单词集合都是正规集</strong></p><ul><li><code>正规集</code>可以用<code>正规式</code>表示</li><li><code>正规式</code>是表示<code>正规集</code>的一种办法</li><li>一个字集合是<code>正规集</code>当且仅当它能用<code>正规式</code>表示</li></ul><h4 id="正规式和正规集的递归定义"><a href="#正规式和正规集的递归定义" class="headerlink" title="正规式和正规集的递归定义"></a>正规式和正规集的递归定义</h4><p>对于给定的字母表Σ：</p><ol><li><p><code>ε</code> (空字)和 <code>∅</code>(空集) 都是 Σ上的正规式，它们所表示的正规集为 <code>{ε}</code> 和 <code>∅</code>;</p></li><li><p>任何 <code>a∈Σ</code> ，<code>a</code> 是 <code>Σ</code> 上的正规式，它所表示的正规集为 <code>{a}</code>;</p></li><li><p>假定 e<del>1</del>和 e<del>2</del>都是 <code>Σ</code> 上的正规式，它们所表示的正规集为L(e<del>1</del>) 和L(e<del>2</del>)，则</p><ul><li><p>(e<del>1</del>|e<del>2</del> )为正规式，它所表示的正规集为 L(e<del>1</del>) ∪L(e<del>2</del>)</p></li><li><p>(e<del>1</del>·e<del>2</del> )为正规式，它所表示的正规集为 L(e<del>1</del>)L(e<del>2</del>) (字的集合进行连接运算)</p></li><li><p>(e<del>1</del>)*为正规式，它所表示的正规集为 (L(e<del>1</del>)) *</p><p>仅由有限次使用上述三步骤而定义的表达式才是 <code>Σ</code> 上的正规式，仅由这些正规式表示的字集才是 <code>Σ</code> 上的正规集</p></li></ul></li></ol><p><strong><code>ε</code> 是字、正规式</strong></p><p><strong><code>∅</code>是集合、正规式</strong></p><p><strong><code>a (a ∈Σ)</code> 是字符、字（一个字符a构成的长度为1的字符串）、正规式</strong></p><h4 id="正规式的等价性"><a href="#正规式的等价性" class="headerlink" title="正规式的等价性"></a>正规式的等价性</h4><blockquote><p>若两个正规式所表示的正规集相同，则称这两个正规式等价</p></blockquote><p><img src="%E7%AC%AC5%E8%AE%B2.assets%5Cimage-20200306222625771.png" alt="image-20200306222625771"></p><h4 id="正规式的性质"><a href="#正规式的性质" class="headerlink" title="正规式的性质"></a>正规式的性质</h4><p>对正规式，下列等价成立：</p><ul><li>e<del>1</del>|e<del>2</del> = e<del>2</del>|e<del>1</del> 交换律</li><li>e<del>1</del> |(e<del>2</del>|e<del>3</del>) = (e<del>1</del>|e<del>2</del>)|e<del>3</del> 结合律</li><li>e<del>1</del>(e<del>2</del>e<del>3</del>) = (e<del>1</del>e<del>2</del>)e<del>3</del> 结合律</li><li>e<del>1</del>(e<del>2</del>|e<del>3</del>) = e<del>1</del>e<del>2</del>|e<del>1</del>e<del>3</del> 分配律</li><li>(e<del>2</del>|e<del>3</del>)e<del>1</del> = e<del>2</del>e<del>1</del>|e<del>3</del> e<del>1</del> 分配律</li><li>eε = εe = e    e<del>1</del>e<del>2</del> &lt;&gt; e<del>2</del> e<del>1</del>(e<del>1</del>连接e<del>2</del>不等于(e<del>2</del>连接e<del>1</del>)</li></ul><p><strong>利用正规式的等价性可证明上述性质</strong></p><p><img src="%E7%AC%AC5%E8%AE%B2.assets%5Cimage-20200306225813915.png" alt="image-20200306225813915"></p><p><strong><code>letter(letter|digit)*</code>对应用户自定义标识符</strong></p><p><strong>同一类字符使用同一正规式表示</strong></p><h2 id="5-2-确定有限自动机"><a href="#5-2-确定有限自动机" class="headerlink" title="5.2 确定有限自动机"></a>5.2 确定有限自动机</h2><blockquote><p>对状态图进行形式化，给出数学定义</p></blockquote><p><code>确定有限自动机(Deterministic Finite Automata， DFA)</code> M是一个五元式 M=(S, Σ, f, S<del>0</del>, F)，其中：</p><ul><li>S: 有穷<code>状态集</code></li><li>Σ：输入<code>字母表</code>(有穷)</li><li>f: <code>状态转换函数</code>，为S×Σ→S的单值部分映射，f(s， a)=s’表示：当现行状态为s，输入字符为a时，将状态转换到下一状态s’，s’称为s的一个后继状态</li><li>S<del>0</del> ∈S是唯一的一个<code>初态</code></li><li>F⊆S ：<code>终态集</code>(可空)</li></ul><p><img src="%E7%AC%AC5%E8%AE%B2.assets%5Cimage-20200307133849646.png" alt="image-20200307133849646"></p><h4 id="DFA表示为状态转换图"><a href="#DFA表示为状态转换图" class="headerlink" title="DFA表示为状态转换图"></a>DFA表示为状态转换图</h4><ul><li>假定DFA M含有 <code>m个状态</code> 和 <code>n个输入字符</code></li><li>对应的状态转换图含有m个状态结点，每个结点最多含有n条箭弧射出，且每条箭弧用Σ上的不同的输入字符来作标记</li></ul><ul><li>对于 Σ*中的任何字 α，若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于 α，则称α为DFA M所识别 (接收 )</li><li>DFA M所识别的字的全体记为L(M)</li></ul><p><img src="%E7%AC%AC5%E8%AE%B2.assets%5Cimage-20200307135451228.png" alt="image-20200307135451228"></p><h2 id="5-3-非确定有限自动机"><a href="#5-3-非确定有限自动机" class="headerlink" title="5.3 非确定有限自动机"></a>5.3 非确定有限自动机</h2><p><code>非确定有限自动机 (Nondeterministic Finite Automata，NFA)</code> M是一个五元式 M=(S, Σ, f, S<del>0</del>, F)，其中：</p><ul><li>S: 有穷<code>状态集</code></li><li>Σ：输入<code>字母表</code>(有穷)</li><li>f: <code>状态转换函数</code>，为 S×Σ*（Σ*指Σ上的字） → 2^S^(S状态集的幂集，也就是有S的所有子集构成的集合)的部分映射，f(s,a)=s’（a指一个字而不是字符，s’则为一个状态集合中的某一个状态（可能的状态有多个，也可能是空集））</li><li>S<del>0</del> ⊆S是非空的<code>初态集</code></li><li>F⊆S ：<code>终态集</code>(可空) </li></ul><h4 id="NFA与DFA的区别"><a href="#NFA与DFA的区别" class="headerlink" title="NFA与DFA的区别"></a>NFA与DFA的区别</h4><ul><li>NFA可以有<code>多个初态</code></li><li>弧上的标记可以是 Σ*中的一个字 (甚至可以是一个<code>正规式</code> )，而不一定是单个字符</li><li><code>同一个字</code>可能出现在同状态射出的多条弧上</li></ul><p><strong>DFA是NFA的特例</strong></p><h4 id="NFA的性质"><a href="#NFA的性质" class="headerlink" title="NFA的性质"></a>NFA的性质</h4><ul><li>对于 Σ*中的任何字 α，若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记字连接成的字等于 α (忽略那些标记为 ε的弧 )，则称 α 为NFA M所识别 (接收 )</li><li>NFA M所识别的字的全体记为L(M)</li></ul><p><img src="%E7%AC%AC5%E8%AE%B2.assets%5Cimage-20200307151706864.png" alt="image-20200307151706864"></p><p><strong>NFA更直观，更容易表达设计者的思想</strong></p><h4 id="DFA和NFA"><a href="#DFA和NFA" class="headerlink" title="DFA和NFA"></a>DFA和NFA</h4><ul><li>定义：对于任何两个有限自动机M和M’，如果 L(M)=L(M’)，则称M与M’等价</li><li>自动机理论中一个重要的结论：<code>判定两个自动机等价性的算法是存在的</code></li><li>对于每个NFA M存在一个DFA M’，使得 L(M)=L(M’)</li></ul><p><strong>DFA与NFA识别能力相同!</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>compiler_principles/第1讲</title>
      <link href="/2020/05/08/compiler-principles/di-1-jiang/"/>
      <url>/2020/05/08/compiler-principles/di-1-jiang/</url>
      
        <content type="html"><![CDATA[<h2 id="第1讲"><a href="#第1讲" class="headerlink" title="第1讲"></a>第1讲</h2><h4 id="main-content"><a href="#main-content" class="headerlink" title="main content"></a>main content</h4><ol><li><p>什么是编译程序？</p></li><li><p>编译程序的各个阶段，理解各个阶段的任务，各个阶段所依循的规则。</p><p> <img src="%E7%AC%AC1%E8%AE%B2.assets%5Cimage-20200229170429773.png" alt="image-20200229170429773"></p></li><li><p>会画编译程序的总框</p></li></ol><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><ol><li><p>把某一种高级语言程序等价地转换成另一种低级语言程序（如汇编或机器语言程序）的程序</p></li><li></li><li></li></ol><h2 id="1-1-什么是编译程序"><a href="#1-1-什么是编译程序" class="headerlink" title="1.1 什么是编译程序"></a>1.1 什么是编译程序</h2><h4 id="翻译程序"><a href="#翻译程序" class="headerlink" title="翻译程序"></a>翻译程序</h4><blockquote><p>把某一种语言程序(称为源语言程序)等价地转换成另一种语言程序(称为目标语言程序)的程序</p></blockquote><p><img src="%E7%AC%AC1%E8%AE%B2.assets%5Cimage-20200229113252306.png" alt="image-20200229113252306"></p><h4 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h4><blockquote><p>把某一种高级语言程序等价地转换成另一种低级语言程序(如汇编语言或机器语言程序)的程序</p></blockquote><p><img src="%E7%AC%AC1%E8%AE%B2.assets%5Cimage-20200229113408377.png" alt="image-20200229113408377"></p><p><strong>运行编译程序的称为宿主机，运行目标语言程序的称为目标机</strong></p><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul><li>诊断编译程序(Diagnostic Compiler)：帮助开发人员开发、调试和排错，主要在发现程序的错误</li><li>优化编译程序(Optimizing Compiler)：侧重于提高目标代码的实行效率，能够生成高校的目标代码</li><li>交叉编译程序(Cross Compiler)：产生不同于宿主机的机器代码</li><li>可变目标编译程序(Retargetable Compiler)：不需要重写编译程序中与机器无关的部分，只要改变和目标机器有关的部分</li></ul><h4 id="解释程序"><a href="#解释程序" class="headerlink" title="解释程序"></a>解释程序</h4><blockquote><p>把源语言写的源程序作为输入，但不产生目标 程序，而是边解释边执行源程序</p></blockquote><p><img src="%E7%AC%AC1%E8%AE%B2.assets%5Cimage-20200229114354757.png" alt="image-20200229114354757"></p><h2 id="1-2-为什么要学习编译原理"><a href="#1-2-为什么要学习编译原理" class="headerlink" title="1.2 为什么要学习编译原理"></a>1.2 为什么要学习编译原理</h2><h4 id="计算思维"><a href="#计算思维" class="headerlink" title="计算思维"></a>计算思维</h4><blockquote><p>计算思维是运用计算机科学的基础概念去求解问题、 设计系统和理解人类的行为，它包括了一系列广泛的计算机科学的思维方法</p></blockquote><ul><li>抽象</li><li>自动化</li><li>问题分解</li><li>递归</li><li>权衡</li><li>保护，冗余，容错，纠错和恢复</li><li>利用启发式推理寻求答案</li></ul><h5 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h5><ol><li>忽略一个主题中与当前问题(或目标)无关的那些方面， 以便更充分地注意与当前问题(或目标)有关的方面</li><li>从众多的事物中抽取出共同的、本质性的特征，舍 弃其非本质的特征</li></ol><h5 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h5><blockquote><p>将抽象思维的结果在计算机上实现，是一个将计算思维成果物化的过程，也是将理论成果应用于技术的实践</p></blockquote><ul><li>有限自动机</li><li>预测分析程序</li><li>算符优先分析</li><li>LR分析</li></ul><h5 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h5><blockquote><p>将大规模的复杂问题分解成若 干个较小规模的、更简单的问题加以解决</p></blockquote><p><img src="%E7%AC%AC1%E8%AE%B2.assets%5Cimage-20200229155051400.png" alt="image-20200229155051400"></p><p>编译原理中的问题分解：</p><ol><li>引入中间语言，复杂度与抽象程度介于高级语言程序与膜表语言程序之间，使得一个很难的转换问题分解成两个相对简单的转换问题</li><li>把编译的过程做进一步分解，细分成词法分析，语法分析，语义分析，中间代码生成，优化目标代码生成等多个阶段</li><li>有时候把复杂处理分解成对程序的多次扫描或遍历，每一次遍历都处理一个小问题</li></ol><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><blockquote><p>问题的解决依赖于类似问题的解决，只不过后者的 复杂程度或规模较原来的问题更小</p><p>一旦将问题的复杂程度和规模化简到足够小时，问 题的解法其实非常简单</p></blockquote><p>编译原理中的递归：</p><ol><li>递归下降分析</li><li>基于树的遍历属性计算</li><li>语法制导翻译</li></ol><h5 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h5><blockquote><p>理论研究重在探寻问题求解的方法，对于理论成果的研究运用又需要在能力和运用中作出权衡</p></blockquote><p>编译原理中的权衡：</p><ol><li>用上下文无关文法来描述和处理高级程序设计语言</li><li>优化措施的选择</li></ol><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>HTML/XML分析</li><li>语言处理工具</li><li>搜索引擎</li></ul><p>应用了语言翻译变换的计算机技术：</p><ul><li>用户接口：Shell命令解释器</li><li>查询语言：SQL，XQuery</li><li>网络协议：HTTP， SOAP</li></ul><h2 id="1-3-编译过程"><a href="#1-3-编译过程" class="headerlink" title="1.3 编译过程"></a>1.3 编译过程</h2><p><img src="%E7%AC%AC1%E8%AE%B2.assets%5Cimage-20200229170342770.png" alt="image-20200229170342770"></p><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><blockquote><p>任务: 输入源程序，对构成源程序的字符串进行 扫描和分解，识别出单词符号</p><p>依循的原则：构词规则</p><p>描述工具：有限自动机</p></blockquote><pre class="line-numbers language-txt"><code class="language-txt">for        i        :=        1          to     100      do基本字    标识符   赋值号    整常数        基本字      整常数    基本字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><blockquote><p>任务：在词法分析的基础上，根据语法规则把 单词符号串分解成各类语法单位 (语法范畴 )</p><p>依循的原则：语法规则</p><p>描述工具：上下文无关文法</p></blockquote><p><img src="%E7%AC%AC1%E8%AE%B2.assets%5Cimage-20200229171637192.png" alt="image-20200229171637192"></p><h4 id="中间代码产生"><a href="#中间代码产生" class="headerlink" title="中间代码产生"></a>中间代码产生</h4><blockquote><p>任务：对各类语法单位按语言的语义进行初步翻译 </p><p>依循的原则：语义规则</p><p>描述工具：属性文法</p><p>中间代码：三元式，四元式，树，… </p></blockquote><p>Z:=X + 0.618 * Y 翻译成四元式为:</p><p><img src="%E7%AC%AC1%E8%AE%B2.assets%5Cimage-20200229171829152.png" alt="image-20200229171829152"></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><blockquote><p>任务：对前阶段产生的中间代码进行加工变换， 以期在最后阶段产生更高效的目标代码</p><p>依循的原则：程序的等价变换规则</p></blockquote><h4 id="目标代码产生"><a href="#目标代码产生" class="headerlink" title="目标代码产生"></a>目标代码产生</h4><blockquote><p>任务: 把中间代码变换成特定机器上的目标代码 </p><p>依赖于硬件系统结构和机器指令的含义</p></blockquote><p>目标代码三种形式：</p><ul><li>汇编指令代码：需要进行汇编</li><li>绝对指令代码：可直接运行</li><li>可重定位指令代码：需要链接</li></ul><h2 id="1-4-编译程序的结构"><a href="#1-4-编译程序的结构" class="headerlink" title="1.4 编译程序的结构"></a>1.4 编译程序的结构</h2><h4 id="编译程序总框"><a href="#编译程序总框" class="headerlink" title="编译程序总框"></a>编译程序总框</h4><p><img src="%E7%AC%AC1%E8%AE%B2.assets%5Cimage-20200229183106660.png" alt="image-20200229183106660"></p><ul><li>符号表管理：完成编译过程中各种对象的信息的存储，组织和修改，为各阶段的分析和转换提供依据，存储信息</li><li>出错处理程序：发现源程序中的错误，把有关错误信息报告给用户，<strong>甚至给出纠错建议</strong><ul><li>语法错误<ul><li>源程序中不符合语法（或词法）规则的错误</li><li>非法字符、括号不匹配、缺少等</li></ul></li><li>语义错误<ul><li>源程序中不符合语义规则的错误</li><li>说明错误、作用域错误、类型不一致等</li></ul></li></ul></li></ul><h4 id="遍-pass"><a href="#遍-pass" class="headerlink" title="遍(pass)"></a>遍(pass)</h4><blockquote><p>所谓”遍”， 就是对源程序或源程序的中间表示从头到尾扫描一次</p></blockquote><p><strong>阶段与遍是不同的概念</strong>：</p><ul><li>一遍可以由若干段组成</li><li>一个阶段也可以分若干遍来完成</li></ul><h4 id="编译前端与后端"><a href="#编译前端与后端" class="headerlink" title="编译前端与后端"></a>编译前端与后端</h4><p>前端：</p><blockquote><p>与源语言有关，如词法分析，语法分析，语义分析与中间代码产生，与机器无关的优化</p></blockquote><p>后端：</p><blockquote><p>与目标机有关，与目标机有关的优化，目标代码产生</p></blockquote><h2 id="1-5-编译程序生成"><a href="#1-5-编译程序生成" class="headerlink" title="1.5 编译程序生成"></a>1.5 编译程序生成</h2><p><img src="%E7%AC%AC1%E8%AE%B2.assets%5Cimage-20200229203247891.png" alt="image-20200229203247891"></p><h4 id="编译程序的移植"><a href="#编译程序的移植" class="headerlink" title="编译程序的移植"></a>编译程序的移植</h4><p><img src="%E7%AC%AC1%E8%AE%B2.assets%5Cimage-20200229210817947.png" alt="image-20200229210817947"></p><h4 id="编译程序自动产生"><a href="#编译程序自动产生" class="headerlink" title="编译程序自动产生"></a>编译程序自动产生</h4><blockquote><p>编译程序-编译程序，编译程序产生器，编译程序书写系统</p></blockquote><ul><li>LEX：词法分析程序产生器</li><li>YACC：语法分析程序产生器</li></ul><p><img src="%E7%AC%AC1%E8%AE%B2.assets%5Cimage-20200229211018928.png" alt="image-20200229211018928"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>compiler_principles/第2讲</title>
      <link href="/2020/05/08/compiler-principles/di-2-jiang/"/>
      <url>/2020/05/08/compiler-principles/di-2-jiang/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-常用的高级程序设计语言"><a href="#2-1-常用的高级程序设计语言" class="headerlink" title="2.1 常用的高级程序设计语言"></a>2.1 常用的高级程序设计语言</h2><h2 id="2-2-程序设计语言的定义"><a href="#2-2-程序设计语言的定义" class="headerlink" title="2.2 程序设计语言的定义"></a>2.2 程序设计语言的定义</h2><p><strong>标识符是语法概念，名字是语义概念</strong></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><blockquote><p>程序本质上是一定字符集上的字符串</p><p>语法：一组规则，用它可以形成和产生一个合式(well-formed)的程序</p></blockquote><h5 id="词法规则：单词符号的形成规则"><a href="#词法规则：单词符号的形成规则" class="headerlink" title="词法规则：单词符号的形成规则"></a>词法规则：单词符号的形成规则</h5><ul><li><p>单词符号是语言中具有独立意义的最基本结构</p></li><li><p>一般包括：常数、标识符、基本字、算符、界符等</p></li><li><p>描述工具：有限自动机（描述程序设计语言的词法规则）</p></li></ul><h5 id="语法规则：语法单位的形成规则"><a href="#语法规则：语法单位的形成规则" class="headerlink" title="语法规则：语法单位的形成规则"></a>语法规则：语法单位的形成规则</h5><ul><li>语法单位通常包括：表达式、语句、分程序、过程、 函数、程序等</li><li>描述工具：上下文无关文法</li></ul><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><pre class="line-numbers language-txt"><code class="language-txt">E→iE→E+EE→E*EE→(E)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>语法规则和词法规则定义了程序的<strong>形式结构</strong></p><p>定义语法单位的意义属于语义问题</p></blockquote><h4 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h4><blockquote><p>一组规则，用它可以定义一个程序的意义</p></blockquote><p>描述方法：</p><ul><li>自然语言描述<ul><li>二义性、隐藏错误和不完整性</li></ul></li><li>形式描述<ul><li>操作语义</li><li>指称语义</li><li>代数语义</li></ul></li></ul><h4 id="程序的基本功能和层次结构"><a href="#程序的基本功能和层次结构" class="headerlink" title="程序的基本功能和层次结构"></a>程序的基本功能和层次结构</h4><blockquote><p>程序，本质上说是描述一定数据的处理过程</p><p>程序语言的基本功能：描述数据和对数据的运算</p></blockquote><p>程序的层次结构：</p><p><img src="%E7%AC%AC2%E8%AE%B2.assets%5Cimage-20200229235118402.png" alt="image-20200229235118402"></p><h2 id="2-3-高级语言程序设计语言的一般特性"><a href="#2-3-高级语言程序设计语言的一般特性" class="headerlink" title="2.3 高级语言程序设计语言的一般特性"></a>2.3 高级语言程序设计语言的一般特性</h2><h4 id="高级语言的分类"><a href="#高级语言的分类" class="headerlink" title="高级语言的分类"></a>高级语言的分类</h4><ul><li>强制式语言(Imperative Languge)/过程式语言<ul><li>命令驱动，面向语句</li><li>FORTRAN、C、Pascal，Ada</li></ul></li><li>应用式语言<ul><li>注重程序所表示的功能，而不是一个语句接一个语 句地执行</li><li>LISP、ML</li></ul></li><li>基于规则的语言( Rule-based Language)<ul><li>检查一定的条件，当它满足值，则执行适当的动作</li><li>Prolog</li></ul></li><li>面向对象语言(Object-Oriented Language)<ul><li>封装、继承和多态性</li><li>Smalltalk，C++，Java</li></ul></li></ul><h4 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h4><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><ul><li>作用域：一个名字能被使用的区域范围</li><li>同一个标识符在不同过程中代表不同的名字</li><li>名字作用域规则——“最近嵌套原则”</li></ul><h5 id="最近嵌套原则"><a href="#最近嵌套原则" class="headerlink" title="最近嵌套原则"></a>最近嵌套原则</h5><ul><li>一个在子程序B1中说明的名 字X只在B1中有效（局部于 B1）</li><li>如果B2是B1的一个内层子 程序且B2中对标识符X没有新的说明，则原来的名字X 在B2中仍然有效</li><li>如果B2对X重新作了说明， 那么，B2对X的任何引用都是指重新说明过的这个X</li></ul><p><img src="%E7%AC%AC2%E8%AE%B2.assets%5Cimage-20200301103438757.png" alt="image-20200301103438757"></p><h4 id="数据结构与操作"><a href="#数据结构与操作" class="headerlink" title="数据结构与操作"></a>数据结构与操作</h4><p>数据类型通常包含三要素：</p><ul><li>用于区别这种类型数据对象的<strong>属性</strong></li><li>这种类型的数据对象可以具有的<strong>值</strong></li><li>可以作用于这种类型的数据对象的<strong>操作</strong></li></ul><h4 id="标识符与名字"><a href="#标识符与名字" class="headerlink" title="标识符与名字"></a>标识符与名字</h4><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><p>数组</p></li><li><p>内情向量</p></li><li><p>登记维数，各维的上、下限，首地址，以及数组 （元素）的类型等信息</p></li><li><p>记录</p><ul><li><p>由已知类型的数据组合在一起的一种结构</p></li><li><p>记录或者结构的元素，也叫做域(field) </p><pre class="line-numbers language-pascal"><code class="language-pascal">  <span class="token keyword">record</span> <span class="token comment" spellcheck="true">{       char name[20];      integer age;      bool married;  }</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>字符串、表格、栈</p></li><li><p>抽象数据类型</p></li></ul><h5 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h5><ul><li>数据对象的集合</li><li>作用于这些对象的抽象运算集合</li><li>这种类型对象的封装，即除了使用类型中所定义的运算之外，用户不能对这些对象进行操作</li></ul><h4 id="语句与控制结构"><a href="#语句与控制结构" class="headerlink" title="语句与控制结构"></a>语句与控制结构</h4><h5 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h5><blockquote><p>表达式由运算量（也称操作数，即数据引用或函数 调用）和算符（运算符，操作符）组成</p><p>形式：中缀(X*Y)、前缀(-A)、后缀(P↑或者p-&gt;)</p></blockquote><p>表达式形成规则：</p><ul><li>变量（包括下标变量）、常数是表达式</li><li>若E1、E 2为表达式， θ是一个二元算符，则E1θE2是表达式</li><li>若E是表达式， θ为一元算符，则 θE（或E θ）是表达式</li><li><strong>若E是表达式，则（E）是表达式</strong></li></ul><h5 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h5><p>赋值语句：A = B</p><p>名字的左值：该名字代表的存储单元的地址</p><p>名字的右值：该名字代表的存贮单元的内容</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>compiler_principles/第3讲</title>
      <link href="/2020/05/08/compiler-principles/di-3-jiang/"/>
      <url>/2020/05/08/compiler-principles/di-3-jiang/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-上下文无关文法"><a href="#3-1-上下文无关文法" class="headerlink" title="3.1 上下文无关文法"></a>3.1 上下文无关文法</h2><h4 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h4><blockquote><p>描述语言的语法结构的形式规则</p></blockquote><p><img src="%E7%AC%AC3%E8%AE%B2.assets%5Cimage-20200303184741423.png" alt="image-20200303184741423"></p><h4 id="语言描述的基本概念"><a href="#语言描述的基本概念" class="headerlink" title="语言描述的基本概念"></a>语言描述的基本概念</h4><ul><li>字母表：一个有穷字符集，记为∑</li><li>字母表中每个元素称为字符</li><li>∑上的 字(也叫字符串) 是指由∑中的字符所构成 的一个有穷序列</li><li>不包含任何字符的序列称为空字，记为ε</li><li>用∑*表示∑上的所有字的全体，包含空字ε</li><li>例如: 设 ∑={a， b}，则 ∑*={ ε,a,b,aa,ab,ba,bb,aaa,…}</li></ul><ul><li>∑ *的子集 U 和 V 的连接 （ 积）定义为</li></ul><p>$$<br>UV ＝{ αβ \space | \space α∈U \space &amp; \space β∈V}<br>$$</p><p>$$<br>U = { a, aa}\<br>    V = {b, bb}\<br>    UV = {ab, abb, aab, aabb}<br>$$</p><p>$$<br>\begin{align<em>}<br>V^n &amp;= VVVVV…V\<br>V^0 &amp;= {ε}\<br>V^</em> 是V的闭包\space\space\space V^* &amp;= V^0∪V^1∪V^2∪V^3∪…\<br>V^+是V的正规闭包：V^＋ &amp;＝ V V^*<br>\end{align*}<br>$$</p><h4 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h4><ul><li><p>上下文无关文法G是一个四元组 ==G=(V <del>T</del>，V<del>N</del>，S，P)== </p><ul><li><p>V<del>T</del> ：终结符(Terminal)集合(非空)</p></li><li><p>V<del>N</del>：非终结符(Noterminal)集合(非空)，且V<del>T</del> ∩ V<del>N</del>= ∅</p></li><li><p>S：文法的开始符号，S ∈ V<del>N</del></p></li><li><p>P：产生式集合(有限)，每个产生式形式为<br>  $$<br>  P→α， P∈V_N， α ∈ (V_T∪V_N)*<br>  $$</p></li></ul></li></ul><p><strong>终结符在文法中是可以再分解与定义的</strong></p><p><img src="%E7%AC%AC3%E8%AE%B2.assets%5Cimage-20200304173936242.png" alt="image-20200304173936242"></p><p><img src="%E7%AC%AC3%E8%AE%B2.assets%5Cimage-20200304174730515.png" alt="image-20200304174730515"></p><h2 id="3-2-文法与语言"><a href="#3-2-文法与语言" class="headerlink" title="3.2 文法与语言"></a>3.2 文法与语言</h2><h4 id="文法生成语言"><a href="#文法生成语言" class="headerlink" title="文法生成语言"></a>文法生成语言</h4><h5 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h5><blockquote><p>定义：称αAβ直接推出αγβ，即 αAβ =&gt; αγβ</p><p>仅当A → γ是一个产生式，且α， β∈ (V<del>T</del> ∪ V<del>N</del>)* 。</p></blockquote><ul><li>如果α<del>1</del> =&gt; α<del>2</del> =&gt; … =&gt;α<del>n</del>，则我们称这个序列是从α<del>1</del>到α<del>n</del>的一个推导。若存在一个从α<del>1</del>到α<del>n</del>的推导，则称α<del>1</del>可以推导出α<del>n</del></li><li>对文法G(E)： E → i | E+E | E*E | (E)：<ul><li>E =&gt; (E) =&gt; (E+E) =&gt; (i+E) =&gt; (i+i) </li></ul></li></ul><h5 id="句型、句子和语言"><a href="#句型、句子和语言" class="headerlink" title="句型、句子和语言"></a>句型、句子和语言</h5><p><em>假定 G是一个文法，S 是它的开始符号</em></p><ul><li><p>如果 𝑆∗ ⇒ 𝛼，则称 α是一个==句型==</p></li><li><p>仅含终结符号的句型是一个==句子==</p></li><li><p>文法G所产生的句子的全体是一个==语言==，记为 L(G)：<br>  $$<br>  L(G) = { α | S =&gt; α,  α ∈ V_T^<em>}<br>  $$<br>  *</em>α由终结符构成，并能够由文法的开始符号推出来**</p></li></ul><h5 id="文法与语言"><a href="#文法与语言" class="headerlink" title="文法与语言"></a>文法与语言</h5><p><img src="%E7%AC%AC3%E8%AE%B2.assets%5Cimage-20200304233248471.png" alt="image-20200304233248471"></p><p><img src="%E7%AC%AC3%E8%AE%B2.assets%5Cimage-20200304233734274.png" alt="image-20200304233734274"></p><h2 id="3-3-语法树与二义性"><a href="#3-3-语法树与二义性" class="headerlink" title="3.3 语法树与二义性"></a>3.3 语法树与二义性</h2><h4 id="最左推导和最右推导"><a href="#最左推导和最右推导" class="headerlink" title="最左推导和最右推导"></a>最左推导和最右推导</h4><blockquote><p>从一个句型到另一个句型的推导往往不唯一</p></blockquote><p>$$<br>E + E =&gt; i + E =&gt; i + i\<br>E + E =&gt; E + i =&gt; i + i<br>$$</p><ul><li><strong>最左推导</strong>：任何一步 α =&gt; β都是对 α中的最左非终结符进行替换</li><li><strong>最右推导</strong>：任何一步 α =&gt; β都是对 α中的最右非终结符进行替换</li></ul><h4 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h4><blockquote><p>用一张图表示一个句型的推导,称为语法树</p><p>以开始符号为根节点，不断增长，当用一条规则把一个非终结符号替换成其候选式时，就从该非终结符对应的结点乡下生长出一颗子树，这棵子树以候选的符号作为结点，随着推导的进行，最终这个树中所有叶结点从左到右排列起来就是要推导出的句型</p></blockquote><p><strong>一棵语法树是不同推导过程的共性抽象</strong>（最左推导与最右推导的语法树一样）</p><h4 id="语法树与二义性-ambiguity"><a href="#语法树与二义性-ambiguity" class="headerlink" title="语法树与二义性(ambiguity)"></a>语法树与二义性(ambiguity)</h4><blockquote><p>文法的二义性：如果一个文法存在某个句子对应两棵不同的语法树，则说这个文法是二义的 G(E)： E → i|E+E|E*E|(E) 是二义文法</p></blockquote><blockquote><p>语言的二义性：一个语言是二义的，如果对它不存在无二义的文法</p></blockquote><ul><li>对于语言L，可能存在G和G’，使得 L(G)=L(G’)=L，有可能其中一个文法为二义的， 另一个为无二义的（只要语言有一个无二义的文法，则这个语言不是二义的）</li></ul><blockquote><p>二义性问题是不可判定问题，即不存在一个算法，它能在有限步骤内，确切地判定一个文法是否是二义的</p></blockquote><ul><li>可以找到一组无二义文法的充分条件（不满足此条件的，有无二义性都是可能的）</li></ul><h2 id="3-4-形式语言鸟瞰"><a href="#3-4-形式语言鸟瞰" class="headerlink" title="3.4 形式语言鸟瞰"></a>3.4 形式语言鸟瞰</h2><ul><li>0型(短语文法，图灵机)<ul><li>产生式形如： α→β</li><li>其中：α∈ (V<del>T</del> ∪ V<del>N</del>)^<em>^且至少含有一个非终结符；β∈ (V<del>T</del> ∪ V<del>N</del>)^</em>^</li></ul></li><li>1型(上下文有关文法，线性界限自动机)<ul><li>产生式形如： α→β</li><li>其中：|α| ≤ |β|，仅 S→ε 例外</li></ul></li><li>2型(上下文无关文法，非确定下推自动机)<ul><li>产生式形如： A → β</li><li>其中：A∈ V<del>N</del>；β∈ (V<del>T</del> ∪ V<del>N</del>)</li></ul></li><li>3型(正规文法，有限自动机)<ul><li>右线性文法<ul><li>产生式形如： A → αB 或 A → α</li><li>其中： α∈ V<del>T</del>*；A，B∈V<del>N</del></li></ul></li><li>左线性文法<ul><li>产生式形如： A → Bα 或 A → α</li><li>其中： α∈ V<del>T</del>*；A，B∈V<del>N</del></li></ul></li></ul></li></ul><p><img src="%E7%AC%AC3%E8%AE%B2.assets%5Cimage-20200305160533722.png" alt="image-20200305160533722"></p><h4 id="上下文无关文法与上下文有关文法"><a href="#上下文无关文法与上下文有关文法" class="headerlink" title="上下文无关文法与上下文有关文法"></a>上下文无关文法与上下文有关文法</h4><ul><li><p>L<del>5</del>={a^n^ b^n^|n ≥1} 不能由正规文法产生，但可由上下文无关文法产生<br>  $$<br>  G_5(S)： S → aSb|ab<br>  $$</p></li><li><p>L<del>6</del>={a^n^ b^n^ c^n^|n ≥1}不能由上下文无关文法产生，但可由上下文有关文法产生</p></li></ul><p>$$<br>\begin{align<em>}<br>G_6(S):S &amp;→ aSBC| aBC\<br>CB &amp;→ BC\<br>aB &amp;→ ab\<br>bB &amp;→ bb\<br>bC &amp;→ bc\<br>cC &amp;→ cc\<br>\end{align</em>}<br>$$</p><p>$$<br>\begin{align<em>}S<br>&amp;=&gt; aSBC\<br>&amp;=&gt; aaSBCBC\<br>&amp;=&gt; aaaBCBCBC\<br>&amp;=&gt; aaaBBCCBC\<br>&amp;=&gt; aaaBBCBCC\<br>&amp;=&gt; aaaBBBCCC\<br>&amp;=&gt; aaabBBCCC\<br>&amp;=&gt; aaabbBCCC\<br>&amp;=&gt; aaabbbCCC\<br>&amp;=&gt; aaabbbcCC\<br>&amp;=&gt; aaabbbccC\<br>&amp;=&gt; aaabbbccc<br>\end{align</em>}<br>$$</p><h4 id="程序设计语言的描述"><a href="#程序设计语言的描述" class="headerlink" title="程序设计语言的描述"></a>程序设计语言的描述</h4><ul><li>程序设计语言不是上下文无关语言，甚至不是上下文有关语言</li><li>L<del>7</del>={ αcα| α∈{a,b}* }不能由上下文无关文法产生， 甚至连上下文有关文法也不能产生，只能由 0 型文法产生<ul><li>标识符引用（先声明后使用）</li><li>过程调用过程中，“形 - 实参数的对应性”（如个数，顺序和类型一致性）</li></ul></li><li>对于现今程序设计语言，在编译程序中，仍然采用上下文无关文法来描述其语言结构，超出上下文无关/有关文法描述能力的那部分语言约束，可以合并到语义分析阶段去做（如检查标识符是否先声明后使用）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>compiler_principles/第15讲</title>
      <link href="/2020/05/08/compiler-principles/di-15-jiang/"/>
      <url>/2020/05/08/compiler-principles/di-15-jiang/</url>
      
        <content type="html"><![CDATA[<h1 id="属性文法和语法制导翻译2"><a href="#属性文法和语法制导翻译2" class="headerlink" title="属性文法和语法制导翻译2"></a>属性文法和语法制导翻译2</h1><h2 id="S-属性文法"><a href="#S-属性文法" class="headerlink" title="S-属性文法"></a>S-属性文法</h2><h4 id="S-属性文法的自下而上计算"><a href="#S-属性文法的自下而上计算" class="headerlink" title="S-属性文法的自下而上计算"></a>S-属性文法的自下而上计算</h4><ul><li><p>S-属性文法：只含有综合属性</p></li><li><p>在自下而上的分析器分析输入符号串的同时计算综合属性</p><ul><li><p>分析栈中保存语法符号和有关的综合属性值</p></li><li><p>每当进行归约时，新的语法符号的属性值就由栈中正在归约的产生式右边符号的属性值来计算</p></li><li><p>假设产生式A → XYZ对应的语义规则为 a := f(X.x, Y.y, Z.z)</p></li></ul></li></ul><p><img src="%E7%AC%AC15%E8%AE%B2.assets/image-20200412232422364.png" alt="image-20200412232422364"></p><p><img src="%E7%AC%AC15%E8%AE%B2.assets/image-20200412213818775.png" alt="image-20200412213818775"></p><h2 id="L属性文法"><a href="#L属性文法" class="headerlink" title="L属性文法"></a>L属性文法</h2><h4 id="一遍扫描的处理方法"><a href="#一遍扫描的处理方法" class="headerlink" title="一遍扫描的处理方法"></a>一遍扫描的处理方法</h4><ul><li>一遍扫描的处理方法<ul><li>所采用的语法分析方法</li><li>属性的计算次序</li></ul></li><li><strong>S-属性文法</strong>适合一遍扫描的自下而上分析</li><li><strong>L-属性文法</strong>适合一遍扫描的自上而下分析</li></ul><h4 id="L-属性文法和自顶向下翻译"><a href="#L-属性文法和自顶向下翻译" class="headerlink" title="L-属性文法和自顶向下翻译"></a>L-属性文法和自顶向下翻译</h4><ul><li>按照深度优先遍历语法树，计算所有属性值</li><li>与LL(1) 自上而下分析方法结合<ul><li>深度优先建立语法树</li><li>按照语义规则计算属性</li></ul></li></ul><h4 id="L-属性文法"><a href="#L-属性文法" class="headerlink" title="L-属性文法"></a>L-属性文法</h4><p>一个属性文法称为<strong>L-属性文法</strong>，如果对于每个产生式<strong>A → X<del>1</del>X<del>2</del>…X<del>n</del></strong>，其每个语义规则中的每个属性或者是综合属性，或者是X<del>i</del>(1≤i≤n)的一个继承属性且这个继承属性仅依赖于：</p><ul><li><strong>产生式中Xi左边符号</strong>X<del>1</del>, X<del>2</del>, …, X<del>i-1</del>的属性</li><li>A的继承属性</li></ul><p><strong>S-属性文法一定是L-属性文法</strong></p><h2 id="翻译模式"><a href="#翻译模式" class="headerlink" title="翻译模式"></a>翻译模式</h2><ul><li><strong>语义规则</strong>：给出了属性计算的定义，没有属性计算的次序等实现细节</li><li><strong>翻译模式</strong>：给出使用语义规则进行计算的次序，把实现细节表示出来</li><li>在翻译模式中，和文法符号相关的属性和语义规则（也称<strong>语义动作</strong>），用花括号{}括起来，插入到产生式右部的合适位置上</li></ul><p>示例：</p><p><img src="%E7%AC%AC15%E8%AE%B2.assets/image-20200413101323202.png" alt="image-20200413101323202"></p><h4 id="设计翻译模式的原则"><a href="#设计翻译模式的原则" class="headerlink" title="设计翻译模式的原则"></a>设计翻译模式的原则</h4><ul><li>设计翻译模式时，必须保证当某个动作引用一个属性时它必须是有定义的</li><li><strong>L-属性文法</strong>本身就能确保每个动作不会引用尚未计算出来的属性</li></ul><h4 id="建立翻译模式"><a href="#建立翻译模式" class="headerlink" title="建立翻译模式"></a>建立翻译模式</h4><ul><li>当只需要<strong>综合属性</strong>时：为每一个语义规则建立一个包含赋值的动作，并把这个动作放在相应的<strong>产生式右边的末尾</strong></li></ul><p><img src="%E7%AC%AC15%E8%AE%B2.assets/image-20200413103112873.png" alt="image-20200413103112873"></p><ul><li><p>如果既有综合属性又有继承属性，在建立翻译模式时就必须保证：</p><ol><li><p>产生式右边的符号的<strong>继承属性</strong>必须在这个符号以前的动作中计算出来</p></li><li><p>一个动作不能引用这个动作右边的符号的<strong>综合属性</strong>（<strong>某语义规则所引用到的属性一定不能出现它右边符号的属性，右边符号的属性要等右边符号完全匹配完后才能够得到</strong>）</p></li><li><p>产生式左边非终结符的<strong>综合属性</strong>只有在它所引用的所有属性都计算出来以后才能计算。计算这种属性的动作通常可放在产生式右端的<strong>末尾</strong></p></li></ol></li></ul><p><img src="%E7%AC%AC15%E8%AE%B2.assets/image-20200413105448332.png" alt="image-20200413105448332"></p><p>左边的产生式违反了第1条，在自伤而下的分析中，A  → a 产生式使用的规则中的属性未定义。</p><h4 id="翻译模式示例"><a href="#翻译模式示例" class="headerlink" title="翻译模式示例"></a>翻译模式示例</h4><h5 id="数学格式语言EQN"><a href="#数学格式语言EQN" class="headerlink" title="数学格式语言EQN"></a>数学格式语言EQN</h5><p><img src="%E7%AC%AC15%E8%AE%B2.assets/image-20200413110216866.png" alt="image-20200413110216866"></p><p><img src="%E7%AC%AC15%E8%AE%B2.assets/image-20200413112225361.png" alt="image-20200413112225361"></p><h4 id="语义动作执行时机统一"><a href="#语义动作执行时机统一" class="headerlink" title="语义动作执行时机统一"></a>语义动作执行时机统一</h4><ul><li>把所有的语义动作都放在产生式的末尾<ul><li>语义动作的执行时机统一</li></ul></li><li>转换方法<ul><li>加入新产生式M → ε</li><li>把嵌入在产生式中的每个语义动作用不同的非终结符M代替，并把这个动作放在产生式M→ε的末尾</li></ul></li></ul><p><img src="%E7%AC%AC15%E8%AE%B2.assets/image-20200413112903178.png" alt="image-20200413112903178"></p><h4 id="消除翻译模式中的左递归"><a href="#消除翻译模式中的左递归" class="headerlink" title="消除翻译模式中的左递归"></a>消除翻译模式中的左递归</h4><ul><li>语义动作是在相同位置上的符号被展开（匹配成功）时执行的</li><li>为了构造不带回溯的自顶向下语法分析，必须消除文法中的左递归</li><li>当消除一个翻译模式的基本文法的左递归时同时考虑<strong>属性计算</strong><ul><li>适合带<strong>综合属性</strong>的翻译模式</li></ul></li></ul><p><img src="%E7%AC%AC15%E8%AE%B2.assets/image-20200413115829619.png" alt="image-20200413115829619"></p><p><img src="%E7%AC%AC15%E8%AE%B2.assets/image-20200413115839014.png" alt="image-20200413115839014"></p><h4 id="消除翻译模式中的左递归的一般方法"><a href="#消除翻译模式中的左递归的一般方法" class="headerlink" title="消除翻译模式中的左递归的一般方法"></a>消除翻译模式中的左递归的一般方法</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>compiler_principles/第14讲</title>
      <link href="/2020/05/08/compiler-principles/di-14-jiang/"/>
      <url>/2020/05/08/compiler-principles/di-14-jiang/</url>
      
        <content type="html"><![CDATA[<h1 id="属性文法和语法制导翻译1"><a href="#属性文法和语法制导翻译1" class="headerlink" title="属性文法和语法制导翻译1"></a>属性文法和语法制导翻译1</h1><h2 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h2><h4 id="属性文法概念"><a href="#属性文法概念" class="headerlink" title="属性文法概念"></a>属性文法概念</h4><ul><li>属性文法,也称属性翻译文法</li><li>以上下文无关文法为基础<ul><li>为每个文法符号（终结符或非终结符）配备若干相关的“值”（称为<strong>属性</strong>），代表与文法符号相关信息，如类型、值、代码序列、符号表内容等</li><li>对于文法的每个产生式都配备了一组属性的<strong>语义规则</strong>，对属性进行计算和传递</li><li>语义规则除了数值的计算规则之外，还可以用来描述更为广泛的属性处理功能，如进行类型信息的传递，代码的拼接，符号表的访问和修改，<strong>凡是能够用程序实现的信息处理都可以成为语义规则</strong></li></ul></li></ul><h5 id="综合属性"><a href="#综合属性" class="headerlink" title="综合属性"></a>综合属性</h5><ul><li>自下而上传递信息</li><li>语法规则：根据右部候选式中的符号的属性计算左部被定义符号的<strong>综合属性</strong></li><li>语法树：根据子结点的属性和父结点自身的属性计算父节点的<strong>综合属性</strong></li></ul><p><img src="%E7%AC%AC14%E8%AE%B2.assets/image-20200411160538009.png" alt="image-20200411160538009"></p><h5 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h5><ul><li>自上而下传递信息</li><li>语法规则：根据右部候选式中的符号的属性和左部被定义符号的属性计算右部候选式中的符号的<strong>继承属性</strong></li><li>语法树：根据父结点和兄弟节点的属性计算子结点的<strong>继承属性</strong></li></ul><p><strong>用于变量名的定义：</strong></p><p><img src="%E7%AC%AC14%E8%AE%B2.assets/image-20200411160659356.png" alt="image-20200411160659356"></p><h4 id="属性依赖"><a href="#属性依赖" class="headerlink" title="属性依赖"></a>属性依赖</h4><ul><li><p>对应于每个产生式A → α都有一套与之相关联的语义规则，每条规则的形式为(f是一个函数)：$$b := f(c_1, c_2, …, c_k)$$</p></li><li><p>属性b依赖于属性c<del>1</del>, c<del>2</del>, …, c<del>k</del></p><ul><li>b是A的一个<strong>综合属性</strong>并且c<del>1</del>, c<del>2</del>, …,c<del>k</del>是产生式右边文法符号的属性</li><li>b是产生式右边某个文法符号的一个<strong>继承属性</strong>并且c<del>1</del>, c<del>2</del>, …, c<del>k</del>是A或产生式右边任何文法符号的属性</li></ul></li><li><p><strong>终结符只有综合属性</strong>，由词法分析器提供</p><ul><li>F → digit</li><li>digit.lexval</li></ul></li><li><p><strong>非终结符既可有综合属性也可有继承属性</strong>，文法开始符号的所有继承属性作为属性计算前的初始值</p></li></ul><h4 id="语义规则"><a href="#语义规则" class="headerlink" title="语义规则"></a>语义规则</h4><ul><li>对出现在<strong>产生式右边的继承属性</strong>和出现在<strong>产生式左边的综合属性</strong>都必须提供一个计算规则。属性计算规则中只能使用相应产生式中的文法符号的属性</li><li>出现在<strong>产生式左边的继承属性</strong>和出现在<strong>产生式右边的综合属性</strong>不由所给的产生式的属性计算规则进行计算，由<strong>其它产生式的属性规则计</strong>算或者由属性计算器的参数提供</li></ul><p>语义规则所描述的工作可以包括<strong>属性计算</strong>、<strong>静态语义检查</strong>、<strong>符号表操作</strong>、<strong>代码生成</strong>等。</p><h4 id="带注释的语法树"><a href="#带注释的语法树" class="headerlink" title="带注释的语法树"></a>带注释的语法树</h4><h5 id="综合属性-1"><a href="#综合属性-1" class="headerlink" title="综合属性"></a>综合属性</h5><ul><li>在语法树中，一个结点的<strong>综合属性</strong>的值由其<strong>子结点</strong>和<strong>它本身</strong>的属性值确定</li><li>使用自底向上的方法在每一个结点处使用语义规则计算综合属性的值</li><li>仅使用综合属性的属性文法称<strong>S-属性文法</strong></li></ul><p><img src="%E7%AC%AC14%E8%AE%B2.assets/image-20200411165735175.png" alt="image-20200411165735175"></p><h5 id="继承属性-1"><a href="#继承属性-1" class="headerlink" title="继承属性"></a>继承属性</h5><ul><li>在语法树中，一个结点的<strong>继承属性</strong>由其<strong>父结点</strong> 、其<strong>兄弟结点</strong>和其<strong>本身</strong>的某些属性确定</li><li>用继承属性来表示程序设计语言结构中的上下文依赖关系很方便</li></ul><p><img src="%E7%AC%AC14%E8%AE%B2.assets/image-20200411170233648.png" alt="image-20200411170233648"></p><p><strong>addtype指的是找到id的入口，拿着父节点的集成属性，去填符号表。</strong></p><h2 id="属性计算"><a href="#属性计算" class="headerlink" title="属性计算"></a>属性计算</h2><h4 id="基于属性文法的处理方法"><a href="#基于属性文法的处理方法" class="headerlink" title="基于属性文法的处理方法"></a>基于属性文法的处理方法</h4><ul><li>语义规则的计算<ul><li>产生代码</li><li>在符号表中存放信息</li><li>给出错误信息</li><li>执行任何其它动作</li></ul></li><li>对输入串的翻译就是根据语义规则进行计算</li></ul><p>由源程序的语法结构所驱动的处理办法就是<strong>语法制导翻译法</strong></p><p><strong>输入串 -&gt; 语法树 -&gt; 按照语义规则计算属性</strong></p><p>方法：</p><ul><li>依赖图</li><li>树遍历</li><li>一遍扫描</li></ul><h4 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h4><ul><li><p>在一棵语法树中的结点的继承属性和综合属性之间的相互依赖关系可以由<strong>依赖图(有向图)</strong>来描述</p></li><li><p>为每一个包含过程调用的语义规则引入一个<strong>虚综合属性b</strong>，这样把每一个语义规则都写成<br>  $$<br>  b := f(c_1, c_2,…, c_k)<br>  $$</p></li></ul><p>依赖图中为每一个属性设置一个结点，如果属性b依赖于属性c，则从属性c的结点有一条有向边连到属性b的结点</p><p><img src="%E7%AC%AC14%E8%AE%B2.assets/image-20200411175830706.png" alt="image-20200411175830706"></p><h5 id="依赖图的构建算法"><a href="#依赖图的构建算法" class="headerlink" title="依赖图的构建算法"></a>依赖图的构建算法</h5><p><img src="%E7%AC%AC14%E8%AE%B2.assets/image-20200411180135060.png" alt="image-20200411180135060"></p><h5 id="依赖图示例"><a href="#依赖图示例" class="headerlink" title="依赖图示例"></a>依赖图示例</h5><p><img src="%E7%AC%AC14%E8%AE%B2.assets/image-20200411182655654.png" alt="image-20200411182655654"></p><h4 id="良定义的属性文法"><a href="#良定义的属性文法" class="headerlink" title="良定义的属性文法"></a>良定义的属性文法</h4><ul><li>如果一属性文法不存在属性之间的循环依赖关系，则称该文法为<strong>良定义的</strong></li><li>一个依赖图的任何<strong>拓扑排序</strong>都给出一个语法树中结点的语义规则计算的有效顺序</li></ul><h4 id="属性的计算次序"><a href="#属性的计算次序" class="headerlink" title="属性的计算次序"></a>属性的计算次序</h4><ul><li>基础文法用于建立输入符号串的<strong>语法分析树</strong></li><li>根据语义规则建立<strong>依赖图</strong></li><li>根据依赖图的拓扑排序，得到计算语义规则的 顺序</li></ul><p><strong>输入串 -&gt; 语法树 -&gt; 依赖图 -&gt; 语义规则计算次序</strong></p><p><img src="%E7%AC%AC14%E8%AE%B2.assets/image-20200411183756276.png" alt="image-20200411183756276"></p><h4 id="树遍历"><a href="#树遍历" class="headerlink" title="树遍历"></a>树遍历</h4><ul><li>假设语法树已建立，且树中已带有开始符号的继承属性和终结符的综合属性</li><li>以某种次序遍历语法树，直至计算出所有属性</li><li><strong>深度优先，从左到右的遍历</strong></li></ul><p><img src="%E7%AC%AC14%E8%AE%B2.assets/image-20200412005310127.png" alt="image-20200412005310127"></p><h5 id="树遍历算法示例"><a href="#树遍历算法示例" class="headerlink" title="树遍历算法示例"></a>树遍历算法示例</h5><p><img src="%E7%AC%AC14%E8%AE%B2.assets/image-20200412175311543.png" alt="image-20200412175311543"></p><h4 id="一遍扫描"><a href="#一遍扫描" class="headerlink" title="一遍扫描"></a>一遍扫描</h4><ul><li>在语法分析的同时计算属性值<ul><li>所采用的语法分析方法</li><li>属性的计算次序</li></ul></li><li>所谓<strong>语法制导翻译法</strong>，直观上说就是为文法中每个产生式配上一组语义规则，并且在语法分析的同时执行这些语义规则</li><li>语义规则被计算的时机<ul><li>自上而下分析，一个产生式匹配输入串成功时</li><li>自下而上分析，一个产生式被用于进行归约时</li></ul></li></ul><h5 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h5><p><strong>抽象语法树</strong>(Abstract Syntax Tree, AST)，在语法树中去掉那些对翻译不必要的信息，从而获得更有效的源程序中间表示</p><p><img src="%E7%AC%AC14%E8%AE%B2.assets/image-20200412180004269.png" alt="image-20200412180004269"></p><h5 id="建立表达式的抽象语法树"><a href="#建立表达式的抽象语法树" class="headerlink" title="建立表达式的抽象语法树"></a>建立表达式的抽象语法树</h5><ul><li><strong>mknode(op, left, right)</strong> 建立一个运算符号结点，标号是op，两个域left和right分别指向左子树和右子树</li><li><strong>mkleaf(id, entry)</strong> 建立一个标识符结点，标号为id，一个域entry指向标识符在符号表中的入口</li><li><strong>mkleaf(num, val)</strong> 建立一个数结点，标号为num，一个域val用于存放数的值</li></ul><h5 id="建立抽象语法树的语义规则"><a href="#建立抽象语法树的语义规则" class="headerlink" title="建立抽象语法树的语义规则"></a>建立抽象语法树的语义规则</h5><p><img src="%E7%AC%AC14%E8%AE%B2.assets/image-20200412180717812.png" alt="image-20200412180717812"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>compiler_principles/第13讲</title>
      <link href="/2020/05/08/compiler-principles/di-13-jiang/"/>
      <url>/2020/05/08/compiler-principles/di-13-jiang/</url>
      
        <content type="html"><![CDATA[<h1 id="语法分析-自下而上分析4"><a href="#语法分析-自下而上分析4" class="headerlink" title="语法分析-自下而上分析4"></a>语法分析-自下而上分析4</h1><h2 id="更强的LR分析"><a href="#更强的LR分析" class="headerlink" title="更强的LR分析"></a>更强的LR分析</h2><p><img src="%E7%AC%AC13%E8%AE%B2.assets/image-20200410144346636.png" alt="image-20200410144346636"></p><p>根据当前符号来判断，若当前符号为#，则按第一个项目进行归约，若当前符号为+，则按照第二个项目移进</p><h2 id="SLR-1-分析"><a href="#SLR-1-分析" class="headerlink" title="SLR(1)分析"></a>SLR(1)分析</h2><h4 id="SLR-1-冲突解决办法"><a href="#SLR-1-冲突解决办法" class="headerlink" title="SLR(1)冲突解决办法"></a>SLR(1)冲突解决办法</h4><p>假定LR(0)规范族的一个项目集<br>$$<br>I={\textcolor{skyblue}{A_1→ α•a_1β_1, A_2 → α • a_2 β_2, …,A_m → α • a_m β_m}, \textcolor{red}{B_1 → α•, B_2 → α•, …, B_n → α•}}<br>$$<br>如果集合$$\textcolor{skyblue}{ {a_1, …, a_m} }, \textcolor{red}{FOLLOW(B_1), …, FOLLOW(B_n)}$$两两不相交(包括不得有两个FOLLOW集合有#)，则当状态I面临任何输入符号a 时：</p><ol><li>若a是某个a<del>i</del>，i=1,2,…,m，则移进；</li><li>若a ∈FOLLOW(B<del>i</del>)，i=1,2,…,n，则用产生式B<del>i</del> → α 进行归约；</li><li>此外，报错。</li></ol><p><code>SLR(1)解决办法</code>： <strong>S-Simple， 1-最多向前看一个单词</strong></p><h4 id="SLR-1-分析表的构造"><a href="#SLR-1-分析表的构造" class="headerlink" title="SLR(1)分析表的构造"></a>SLR(1)分析表的构造</h4><p><img src="%E7%AC%AC13%E8%AE%B2.assets/image-20200410182317207.png" alt="image-20200410182317207"></p><h4 id="SLR-1-文法"><a href="#SLR-1-文法" class="headerlink" title="SLR(1)文法"></a>SLR(1)文法</h4><ul><li>按上述方法构造出的ACTION与GOTO表如果不含多重入口，则称该文法为<strong>SLR(1)文法</strong></li><li>使用SLR表的分析器叫做一个<strong>SLR分析器</strong></li><li>每个SLR(1)文法都是无二义的。但也存在许多无二义文法不是SLR(1)的</li><li><strong>LR(0) ⊂ SLR(1) ⊂ 无二义文法</strong></li></ul><h4 id="SLR-1-分析表构造示例"><a href="#SLR-1-分析表构造示例" class="headerlink" title="SLR(1)分析表构造示例"></a>SLR(1)分析表构造示例</h4><p><img src="%E7%AC%AC13%E8%AE%B2.assets/image-20200410184405778.png" alt="image-20200410184405778"></p><h2 id="LR-1-分析法"><a href="#LR-1-分析法" class="headerlink" title="LR(1)分析法"></a>LR(1)分析法</h2><h4 id="一个非SLR-1-文法"><a href="#一个非SLR-1-文法" class="headerlink" title="一个非SLR(1)文法"></a>一个非SLR(1)文法</h4><p><img src="%E7%AC%AC13%E8%AE%B2.assets/image-20200410185242540.png" alt="image-20200410185242540"></p><p>对于状态2识别 <code>=</code> ，由于FOLLOW(R)含有 <code>=</code> ，所以不能判断移进归约，但是对文法进行分析，可知文法中没有以 <code>R=</code> 为前缀的规范句型，只有以 <code>*R=*</code> 为前缀的规范句型，所以状态2中的归约项是无效的。</p><p><strong>需要根据当前栈内的活前缀或其它更具体的信息来判断选择下一个能接受的符号。</strong></p><h4 id="LR-1-分析表的构造"><a href="#LR-1-分析表的构造" class="headerlink" title="LR(1)分析表的构造"></a>LR(1)分析表的构造</h4><ul><li>把G拓广为G′</li><li>对G′构造LR(1)项目集规范族C和活前缀识别自动机的状态转换函数GO</li><li>使用C和GO，构造LR(1)分析表</li></ul><h5 id="LR-k-项目"><a href="#LR-k-项目" class="headerlink" title="LR(k)项目"></a>LR(k)项目</h5><ul><li><strong>LR(k)项目</strong>：扩展LR(0)项目，附带有k个终结符$$[A → α•β, a_1a_2…a_k]$$， a<del>1</del>a<del>2</del>…a<del>k</del> 称为<strong>向前搜索符串</strong>(或展望串)。</li><li>归约项目$$[A → α•β, a_1a_2…a_k]$$的意义：当它所属的状态呈现在栈顶且后续的k个输入符号为 a<del>1</del>a<del>2</del>…a<del>k</del> 时，<strong>才可以把栈顶上的α归约为A</strong>。</li><li>对于任何移进或待约项目$$[A → α•β, a_1a_2…a_k]$$，β ≠ ε，搜索符串 a<del>1</del>a<del>2</del>…a<del>k</del> 没有直接作用</li></ul><h5 id="有效项目"><a href="#有效项目" class="headerlink" title="有效项目"></a>有效项目</h5><p>形式上我们说一个LR(1)项目[A → α•β, a]对于<strong>活前缀γ</strong>是有效的，如果存在规范推导<br>$$<br>S’ \Rightarrow \delta A \omega \Rightarrow \delta \alpha \beta \omega<br>$$</p><ul><li><code>γ ＝ δα</code></li><li>a是ω的第一个符号，或者a为#而ω为ε</li></ul><p><strong>当A归约的瞬间，当时面临的单词应当是a。</strong></p><h5 id="有效项目的性质"><a href="#有效项目的性质" class="headerlink" title="有效项目的性质"></a>有效项目的性质</h5><p><img src="%E7%AC%AC13%E8%AE%B2.assets/image-20200411000611081.png" alt="image-20200411000611081"></p><h4 id="LR-1-分析表构造算法"><a href="#LR-1-分析表构造算法" class="headerlink" title="LR(1)分析表构造算法"></a>LR(1)分析表构造算法</h4><h5 id="项目集的闭包CLOSURE"><a href="#项目集的闭包CLOSURE" class="headerlink" title="项目集的闭包CLOSURE"></a>项目集的闭包CLOSURE</h5><p>假定I是文法G ′的任一项目集，定义和构造I的闭包CLOSURE(I)如下：</p><ol><li>I的任何项目都属于CLOSURE(I)</li><li>若项目[A → α•Bβ, a]属于CLOSURE(I)，B → ξ 是一个产生式，那么，对于FIRST(βa) 中的每个 终结符b，如果[B → •ξ, b]原来不在CLOSURE(I) 中，则把它加进去</li><li>重复执行步骤2，直至CLOSURE(I)不再增大为止</li></ol><h5 id="项目集的转换函数GO"><a href="#项目集的转换函数GO" class="headerlink" title="项目集的转换函数GO"></a>项目集的转换函数GO</h5><p>令I是一个项目集，X是一个文法符号，函数 GO(I，X)定义为：<br>$$<br>GO(I，X)＝CLOSURE(J)\<br>J ＝ { 任何形如[ A→ αX• β, a ]的项目 \space | \space [ A→ α•X β, a ] ∈I }<br>$$<br><strong>J为I读入一个字符X后的项目。</strong></p><h5 id="LR-1-分析表的ACTION和GOTO子表构造"><a href="#LR-1-分析表的ACTION和GOTO子表构造" class="headerlink" title="LR(1)分析表的ACTION和GOTO子表构造"></a>LR(1)分析表的ACTION和GOTO子表构造</h5><p><img src="%E7%AC%AC13%E8%AE%B2.assets/image-20200411003610059.png" alt="image-20200411003610059"></p><h4 id="LR-1-分析表和LR-1-文法"><a href="#LR-1-分析表和LR-1-文法" class="headerlink" title="LR(1)分析表和LR(1)文法"></a>LR(1)分析表和LR(1)文法</h4><ul><li>按上述算法构造的分析表，若不存在多重定义的入口(即，动作冲突)的情形，则称它是文法G的一张规范的<strong>LR(1)分析表</strong></li><li>具有规范的LR(1)分析表的文法称为一个<strong>LR(1)文法</strong></li><li>使用LR(1)分析表的分析器叫做一个<strong>规范的LR分析器</strong></li><li>LR(1)状态比SLR(1)多</li><li><strong>LR(0) ⊂ SLR(1) ⊂ LR(1) ⊂ 无二义文法</strong></li></ul><h4 id="LR-1-分析表构造示例"><a href="#LR-1-分析表构造示例" class="headerlink" title="LR(1)分析表构造示例"></a>LR(1)分析表构造示例</h4><p><img src="%E7%AC%AC13%E8%AE%B2.assets/image-20200411112953729.png" alt="image-20200411112953729"></p><h2 id="分析器产生工具"><a href="#分析器产生工具" class="headerlink" title="分析器产生工具"></a>分析器产生工具</h2><h4 id="YACC"><a href="#YACC" class="headerlink" title="YACC"></a>YACC</h4><p><strong>Yet Another Compiler Compiler</strong></p><ul><li>GNU Bison：基本兼容Yacc，与flex一起使用</li><li>Berkeley Yacc</li></ul><p><a href="http://dinosaur.compilertools.net/" target="_blank" rel="noopener">The Lex &amp; Yacc Page</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>compiler_principles/第12讲</title>
      <link href="/2020/05/08/compiler-principles/di-12-jiang/"/>
      <url>/2020/05/08/compiler-principles/di-12-jiang/</url>
      
        <content type="html"><![CDATA[<h1 id="语法分析-自下而上分析3"><a href="#语法分析-自下而上分析3" class="headerlink" title="语法分析-自下而上分析3"></a>语法分析-自下而上分析3</h1><h2 id="活前缀"><a href="#活前缀" class="headerlink" title="活前缀"></a>活前缀</h2><ul><li><p>字的前缀：是指字的任意首部，如字abc的前缀有 ε，a，ab，abc</p></li><li><p>活前缀：是指<strong>规范句型</strong>的一个前缀，这种前缀不含句柄之后的任何符号</p><ul><li>对于规范句型 αβδ，β为句柄，如果 <strong>αβ = u<del>1</del> u<del>2</del>…u<del>r</del></strong>，则符号串 u<del>1</del>u<del>2</del>…u<del>i</del>(1 ≤i≤r)是αβδ 的活前缀。( δ必为终结符串)</li></ul></li></ul><p><strong>句柄只能在分析栈的顶部，不能在栈内部。</strong></p><p><strong>规范归约过程中，保证分析栈中总是活前缀，就说明分析采取的移进/归约动作是正确的。</strong></p><h2 id="构造识别活前缀的DFA"><a href="#构造识别活前缀的DFA" class="headerlink" title="构造识别活前缀的DFA"></a>构造识别活前缀的DFA</h2><h4 id="文法的拓广"><a href="#文法的拓广" class="headerlink" title="文法的拓广"></a>文法的拓广</h4><ul><li>将文法G(S)拓广为G′(S′)<ul><li>构造文法G′，它包含了整个G，并引进不出现在G中的非终结符S′、以及产生式S′→S，S′是G′的开始符号</li><li>称G′是G的拓广文法</li></ul></li></ul><h4 id="LR-0-项目"><a href="#LR-0-项目" class="headerlink" title="LR(0)项目"></a>LR(0)项目</h4><ul><li>在每个产生式的右部添加一个圆点，表示我们在分析过程中看到了产生式多大部分</li><li><code>A→XYZ</code>有四个项目<ul><li>A→ •XYZ</li><li>A→X•YZ</li><li>A→XY•Z</li><li>A→XYZ•</li></ul></li><li>A→α• 称为”归约项目”</li><li>归约项目 S′→α• 称为”<strong>接受项目</strong>“（整个句子都识别完毕）</li><li>A→α•aβ (a∈V<del>T</del>) 称为”<strong>移进项目</strong>“（下一个读入字符a）</li><li>A→α•Bβ (B∈V<del>N</del>) 称为”<strong>待约项目</strong>“（等待B归约完毕）</li></ul><h4 id="构造识别文法所有活前缀的DFA"><a href="#构造识别文法所有活前缀的DFA" class="headerlink" title="构造识别文法所有活前缀的DFA"></a>构造识别文法所有活前缀的DFA</h4><p><img src="%E7%AC%AC12%E8%AE%B2.assets/image-20200409135513464.png" alt="image-20200409135513464"></p><ul><li>对于上面的NFA，j相比于i多识别了一个X<del>i</del>，因此从状态i画一条标志为X<del>i</del>的有向边到状态j</li><li>对于下面的NFA，如果状态i对应一个<strong>待约项目</strong>，画一个ε边到所有状态A → • γ，当A归约完后，从i射出A弧至状态k</li></ul><h4 id="识别活前缀的NFA"><a href="#识别活前缀的NFA" class="headerlink" title="识别活前缀的NFA"></a>识别活前缀的NFA</h4><p><img src="%E7%AC%AC12%E8%AE%B2.assets/image-20200409162237238.png" alt="image-20200409162237238"></p><h2 id="通过计算项目集规范族构造识别活-前缀的DFA"><a href="#通过计算项目集规范族构造识别活-前缀的DFA" class="headerlink" title="通过计算项目集规范族构造识别活 前缀的DFA"></a>通过计算项目集规范族构造识别活 前缀的DFA</h2><p>构成识别一个文法活前缀的DFA的项目集(状态)的全体称为文法的<strong>LR(0)项目集规范族</strong>。</p><h4 id="有效项目"><a href="#有效项目" class="headerlink" title="有效项目"></a>有效项目</h4><ul><li><p>项目 A → β<del>1</del> • β<del>2</del>对活前缀αβ<del>1</del>是有效的，其条件是存在规范推导<br>  $$<br>  S’ \Rightarrow _R \alpha A \omega \Rightarrow _R \alpha \beta_1 \beta_2 \omega<br>  $$</p></li><li><p>在任何时候，分析栈中的活前缀 X<del>1</del>X<del>2</del> … X<del>m</del> 的有效项目集正是从识别活前缀的DFA的初态出发，读出 X<del>1</del>X<del>2</del> … X<del>m</del> 后到达的那个项目集(状态)</p></li></ul><p><img src="%E7%AC%AC12%E8%AE%B2.assets/image-20200409163257635.png" alt="image-20200409163257635"></p><p><strong>状态5中的产生式对于活前缀bc是有效的（从初态读入bc到达状态5）</strong></p><h4 id="有效项目的性质"><a href="#有效项目的性质" class="headerlink" title="有效项目的性质"></a>有效项目的性质</h4><p><img src="%E7%AC%AC12%E8%AE%B2.assets/image-20200409181732485.png" alt="image-20200409181732485"></p><h2 id="LR-0-项目集规范族的构造"><a href="#LR-0-项目集规范族的构造" class="headerlink" title="LR(0)项目集规范族的构造"></a>LR(0)项目集规范族的构造</h2><ul><li>将文法G(S)拓广为G ′(S ′ )<ul><li>构造文法G ′，它包含了整个G，并引进不出现在G中的非终结符S ′、以及产生式S ′→S，S ′是G ′的开始符号</li><li>G ′唯一的“接受”态：仅含项目S ′ → S•的状态</li></ul></li></ul><h4 id="项目集的闭包CLOSURE"><a href="#项目集的闭包CLOSURE" class="headerlink" title="项目集的闭包CLOSURE"></a>项目集的闭包CLOSURE</h4><p>假定I是文法G’的任一项目集，定义和构造I的包CLOSURE(I)如下： </p><ol><li>I的任何项目都属于CLOSURE(I)； </li><li>若A → α•Bβ属于CLOSURE(I)，那么，对任 何关于A的产生式B → γ，项目B → •γ也属于 CLOSURE(I)；</li><li>重复执行上述两步骤直至CLOSURE(I) 不再增大为止</li></ol><ul><li><p><strong>简单来说第2步就是找等价的产生式，如A → α•Bβ，未读入B，此时可以查找B的产生式右部最左端为•的项目(B → •任意符号)</strong></p></li><li><p><strong>项目的•之后若为终结符或•处于末尾则不用找等价项目</strong></p></li></ul><h4 id="状态转换函数"><a href="#状态转换函数" class="headerlink" title="状态转换函数"></a>状态转换函数</h4><p>为了识别活前缀，我们定义一个状态转换函数 GO。I是一个项目集，X是一个文法符号。</p><p>函数值GO(I，X)定义为： <strong>GO(I，X)＝CLOSURE(J)</strong> </p><p>其中 J＝{任何形如A → αX•β的项目| A → α•Xβ属于I}。</p><p>直观上说，若I是对某个活前缀 γ 有效的项目集， 那么，GO(I，X)便是对 γX 有效的项目集。</p><p><strong>直白点，从I到GO（I,X)这个结果的状态集就是相当于识别了一个X，及I识别X后到达的状态集</strong></p><p><img src="%E7%AC%AC12%E8%AE%B2.assets/image-20200409233500606.png" alt="image-20200409233500606"></p><h2 id="构造LR-0-分析表"><a href="#构造LR-0-分析表" class="headerlink" title="构造LR(0)分析表"></a>构造LR(0)分析表</h2><p>假若一个文法G的拓广文法G ′的活前缀识别自动机中的每个状态(项目集)不存在下述情况：</p><ul><li>既含移进项目又含归约项目</li><li>含有多个归约项目</li></ul><p>则称G是一个<strong>LR(0)文法</strong>。</p><p><img src="%E7%AC%AC12%E8%AE%B2.assets/image-20200409235139113.png" alt="image-20200409235139113"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>compiler_principles/第11讲</title>
      <link href="/2020/05/08/compiler-principles/di-11-jiang/"/>
      <url>/2020/05/08/compiler-principles/di-11-jiang/</url>
      
        <content type="html"><![CDATA[<h1 id="语法分析-自下而上分析2"><a href="#语法分析-自下而上分析2" class="headerlink" title="语法分析-自下而上分析2"></a>语法分析-自下而上分析2</h1><h2 id="句柄和规范归约"><a href="#句柄和规范归约" class="headerlink" title="句柄和规范归约"></a>句柄和规范归约</h2><h4 id="LR分析法"><a href="#LR分析法" class="headerlink" title="LR分析法"></a>LR分析法</h4><ul><li>L：从左到右扫描输入串</li><li>R：自下而上进行归约</li></ul><p><img src="%E7%AC%AC11%E8%AE%B2.assets/image-20200408151348116.png" alt="image-20200408151348116"></p><h4 id="句柄和规范归约-1"><a href="#句柄和规范归约-1" class="headerlink" title="句柄和规范归约"></a>句柄和规范归约</h4><h5 id="短语、直接短语和句柄"><a href="#短语、直接短语和句柄" class="headerlink" title="短语、直接短语和句柄"></a>短语、直接短语和句柄</h5><ul><li>短语：以某非终结符为根的<strong>两代以上的子树的所有末端结点从左到右排列</strong>就是相对于该非终结符的一个短语</li><li>直接短语：如果子树只有两代，则该短语就是直接短语</li><li>句柄：最左两代子树末端就是<strong>句柄</strong></li></ul><p><img src="%E7%AC%AC11%E8%AE%B2.assets/image-20200408152827273.png" alt="image-20200408152827273"></p><h5 id="用句柄归约"><a href="#用句柄归约" class="headerlink" title="用句柄归约"></a>用句柄归约</h5><p><img src="%E7%AC%AC11%E8%AE%B2.assets/image-20200408152857435.png" alt="image-20200408152857435"></p><p>总是找最左两代子树进行归约。</p><h5 id="规范归约"><a href="#规范归约" class="headerlink" title="规范归约"></a>规范归约</h5><p>定义：假定α是文法G的一个句子，我们称序列 αn， αn-1，… ，α0 是α的一个<strong>规范归约</strong>，如果此序列满足：</p><ol><li>α<del>n</del> = α</li><li>α<del>0</del>为文法的开始符号，即α<del>0</del> = S</li><li>对任何i，0 ≤ i ≤ n， α<del>i-1</del>是从α<del>i</del>经把句柄替换成为相应产生式左部符号而得到的</li></ol><h5 id="规范句型"><a href="#规范句型" class="headerlink" title="规范句型"></a>规范句型</h5><ul><li>规范归约是<strong>最左归约</strong></li><li>规范归约的逆过程就是最右推导（S =&gt; aAcBe =&gt; aAcde =&gt; aAbcde =&gt; abbcde）</li><li>最右推导也称为<strong>规范推导</strong></li><li>由规范推导推出的句型称为<strong>规范句型</strong></li></ul><h2 id="LR分析法-1"><a href="#LR分析法-1" class="headerlink" title="LR分析法"></a>LR分析法</h2><p>规范归约的关键问题是寻找句柄。</p><ul><li>历史：已移入符号栈的内容</li><li>展望：根据产生式推测未来可能遇到的输入符号</li><li>现实：当前的输入符号</li></ul><h4 id="LR分析器的结构"><a href="#LR分析器的结构" class="headerlink" title="LR分析器的结构"></a>LR分析器的结构</h4><p>把”历史”及”展望”综合抽象成 状态；由<strong>栈顶的状态</strong>和现行的<strong>输入符号</strong>唯一<strong>确定</strong>每一步工作。</p><p><img src="%E7%AC%AC11%E8%AE%B2.assets/image-20200408182216487.png" alt="image-20200408182216487"></p><h4 id="LR分析表"><a href="#LR分析表" class="headerlink" title="LR分析表"></a>LR分析表</h4><ul><li><strong>ACTION[s，a]</strong>：当状态s面临输入符号a时，应采取什么动作</li><li><strong>GOTO[s，X]</strong>：状态s面对文法符号X时，下一状态是什么</li></ul><p><img src="%E7%AC%AC11%E8%AE%B2.assets/image-20200408182416815.png" alt="image-20200408182416815"></p><ul><li><strong>移进(shift)</strong>：把(s，a)的下一状态s’和输入符号a推进栈，下一输入符号变成现行输入符号</li><li><strong>归约(reduce)</strong>：用某产生式A→β进行归约。 假若β的长度为r， 去除栈顶r个项，使状态s<del>m-r</del>变成栈顶状态，然后把下一状态s’=GOTO[s<del>m-r</del>, A]和文法符号A推进栈</li><li><strong>接受(acc)</strong>：宣布分析成功，停止分析器工作</li><li>空着的即error</li></ul><h4 id="LR分析过程"><a href="#LR分析过程" class="headerlink" title="LR分析过程"></a>LR分析过程</h4><p><img src="%E7%AC%AC11%E8%AE%B2.assets/image-20200408205345528.png" alt="image-20200408205345528"></p><p>用上述三元组即可对分析的每一步进行描述。</p><p>$$<br>(s_0 s_1 … s_m , \space # X_1 … X_m, \space a_{i+1} … a_n #<br>$$<br>分析器根据ACTION(s<del>m</del> , a<del>i</del>)确定下一步动作：</p><ul><li>ACTION(s<del>m</del> , a<del>i</del>)为移进，且<em>s</em>为下一状态，则格局变为:<br>$$<br>(s_0 s_1 …s_m \textcolor{red}{s} , \space # X_1 … X_ma_i, \space \textcolor{red}{a_{i+1}} … a_n #<br>$$</li></ul><ul><li><p>若ACTION(s<del>m</del> , a<del>i</del>)为按$A \to \beta$归约，格局变为:</p><ul><li><strong>此处, s=GOTO(s<del>m-r</del>, A), r为β的长度, β= X<del>m-r+1</del>… Xm</strong><br>$$<br>(s_0 s_1 …s_{m-r} \textcolor{red}{s} , \space # X_1 … X_{m-r} \textcolor{red}{A}, \space ai a_{i+1} … a_n #<br>$$</li></ul></li><li><p>若ACTION(s<del>m</del> , a<del>i</del>)为“接受”，则格局变化过程终止，宣布分析成功</p></li><li><p>若ACTION(s<del>m</del> , a<del>i</del>)为“报错”，则格局变化过程终止，报告错误</p></li></ul><h5 id="归约过程"><a href="#归约过程" class="headerlink" title="归约过程"></a>归约过程</h5><p><img src="%E7%AC%AC11%E8%AE%B2.assets/image-20200408220624518.png" alt="image-20200408220624518"></p><ol><li>弹出被归约符号（句柄）及对应的状态</li><li>将归约后的A压到符号栈的栈顶</li><li>根据<strong>状态s<del>m-r</del></strong>与<strong>A</strong>查GOTO表，将下一个状态压入符号栈</li></ol><h2 id="LR分析示例"><a href="#LR分析示例" class="headerlink" title="LR分析示例"></a>LR分析示例</h2><p>LR分析性质：</p><ul><li>在任何时候，分析栈中的内容和扫描串剩下的内容拼接起来总是一个规范句型</li><li>一旦栈顶出现了当时栈内内容，和栈外输入串拼接出来的句型的句柄，立刻归约</li></ul><p><img src="%E7%AC%AC11%E8%AE%B2.assets/image-20200408223255400.png" alt="image-20200408223255400"></p><p><img src="%E7%AC%AC11%E8%AE%B2.assets/image-20200408223316054.png" alt="image-20200408223316054"></p><p><img src="%E7%AC%AC11%E8%AE%B2.assets/image-20200408223502376.png" alt="image-20200408223502376"></p><p><img src="%E7%AC%AC11%E8%AE%B2.assets/image-20200408223511599.png" alt="image-20200408223511599"></p><h2 id="LR文法"><a href="#LR文法" class="headerlink" title="LR文法"></a>LR文法</h2><ul><li>对于一个文法，如果能够构造一张分析表，使得它的每个入口均是唯一确定的，则这个文法就称为<strong>LR文法</strong></li><li>一个文法，如果能用一个每步顶多向前检查k个输入符号的LR分析器进行分析，则这个文法就称为<strong>LR(k)文法</strong></li></ul><h4 id="LR文法与二义文法"><a href="#LR文法与二义文法" class="headerlink" title="LR文法与二义文法"></a>LR文法与二义文法</h4><ul><li>LR文法不是二义的，二义文法肯定不会是LR的</li><li>LR文法 ⊂ 无二义文法（有一些无二义的文法构造出的LR分析表有冲突，但仍是无二义的）</li><li>非LR结构<ul><li>S → iCtS | iCtSeS</li></ul></li></ul><p><strong>可以手动消除LR分析表中的冲突项</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>compiler_principles/第10讲</title>
      <link href="/2020/05/08/compiler-principles/di-10-jiang/"/>
      <url>/2020/05/08/compiler-principles/di-10-jiang/</url>
      
        <content type="html"><![CDATA[<h1 id="语法分析-自下而上分析1"><a href="#语法分析-自下而上分析1" class="headerlink" title="语法分析-自下而上分析1"></a>语法分析-自下而上分析1</h1><h2 id="自下而上分析"><a href="#自下而上分析" class="headerlink" title="自下而上分析"></a>自下而上分析</h2><p>定义：</p><ul><li>从输入串开始，逐步进行归约，直到文法的开始符号</li><li>归约：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号</li><li><strong>从树叶节点开始，构造语法树</strong></li><li>算符优先分析法、LR分析法</li></ul><p><img src="%E7%AC%AC10%E8%AE%B2.assets/image-20200407233819858.png" alt="image-20200407233819858"></p><h4 id="移进－归约思想"><a href="#移进－归约思想" class="headerlink" title="移进－归约思想"></a>移进－归约思想</h4><ul><li>用一个寄存符号的先进后出栈，把输入符号一个一个地移进到栈里，当栈顶形成某个产生式的候选式时，即把栈顶的这一部分替换成(归约为)该产生式的左部符号</li></ul><p><img src="%E7%AC%AC10%E8%AE%B2.assets/image-20200407233732905.png" alt="image-20200407233732905"></p><p>图中的树称为分析树（区别于语法树）（对于某些分析方法，分析树与语法树不一定完全一样）</p><p>第4步对于b来说，它是一个可归约串，但是对于整个句子来说，它不是一个可归约串</p><h2 id="短语与直接短语"><a href="#短语与直接短语" class="headerlink" title="短语与直接短语"></a>短语与直接短语</h2><h4 id="短语"><a href="#短语" class="headerlink" title="短语"></a>短语</h4><p>令G是一个文法，S是文法的开始符号， 假定αβδ是文法G的一个句型，如果有<br>$$<br>S \Rightarrow \alpha A \delta \space 且 \space A \Rightarrow \beta<br>$$<br>则β称是句型αβδ相对于非终结符A的短语</p><p><img src="%E7%AC%AC10%E8%AE%B2.assets/image-20200407234245525.png" alt="image-20200407234245525"></p><h4 id="直接短语"><a href="#直接短语" class="headerlink" title="直接短语"></a>直接短语</h4><p><strong>如果有A =&gt; β,则称β是句型αβδ相对于规则A→ β的直接短语</strong></p><p>直接短语代表了<strong>可立即归约</strong>的串（不需要与其他串组合）</p><h4 id="短语和直接短语"><a href="#短语和直接短语" class="headerlink" title="短语和直接短语"></a>短语和直接短语</h4><p>在一个句型对应的语法树中:</p><ul><li>以某非终结符为根的<strong>两代以上的子树的所有末端结点从左到右排列</strong>就是相对于该非终结符的一个<strong>短语</strong></li><li>如果子树只有两代，则该短语就是<strong>直接短语</strong></li></ul><p><img src="%E7%AC%AC10%E8%AE%B2.assets%5Cimage-20200320140955945.png" alt="image-20200320140955945"></p><p>短语： i<del>1</del> ，i<del>2</del>，i<del>3</del>， i<del>1</del><em>i<del>2</del> ，i<del>1</del></em>i<del>2</del>+i<del>3</del></p><p>直接短语：i<del>1</del> ，i<del>2</del>，i<del>3</del></p><h2 id="分析过程描述"><a href="#分析过程描述" class="headerlink" title="分析过程描述"></a>分析过程描述</h2><p><img src="%E7%AC%AC10%E8%AE%B2.assets%5Cimage-20200320142039078.png" alt="image-20200320142039078"></p><h2 id="算符优先文法"><a href="#算符优先文法" class="headerlink" title="算符优先文法"></a>算符优先文法</h2><p>如果规定算符的优先次序，并按 这种规定进行归约，则归约过程是唯一的</p><p><img src="%E7%AC%AC10%E8%AE%B2.assets%5Cimage-20200320155409421.png" alt="image-20200320155409421"></p><h4 id="优先关系"><a href="#优先关系" class="headerlink" title="优先关系"></a>优先关系</h4><p>任何两个可能相继出现的终结符a与b可能三种优先关系：</p><ul><li>a &lt; b，a的优先级低于b</li><li>a = b，a的优先级等于b</li><li>a &gt; b，a的优先级高于b</li></ul><p>算符优先关系与数学上的&lt;&gt;=不同</p><ul><li>+ &lt; + 右边的+号优先级高于左边的+号</li><li>a &lt; b并不意味着b &gt; a，如 <code>( &lt; +</code> 和 <code>+ &lt; (</code> (两个符号谁在左边谁的优先级低)</li></ul><h4 id="算符文法"><a href="#算符文法" class="headerlink" title="算符文法"></a>算符文法</h4><p>一个文法，如果它的任一产生式的右部都<strong>不含两个相继(并列)的==非终结符==</strong>，即不含…QR…形式的产生式右部，则我们称该文法为<strong>算符文法</strong></p><h4 id="算符优先文法-1"><a href="#算符优先文法-1" class="headerlink" title="算符优先文法"></a>算符优先文法</h4><p>假定G是一个不含 ε-产生式的算符文法。对于任何一对终结符a、b，我们说：</p><ul><li>a = b，当且仅当文法G中含有形如P→…ab… 或 P→…aQb…的产生式；</li><li>a &lt; b，当且仅当G中含有形如P→…aR…的产生式， 而 R⇒b… 或 R⇒Qb…</li><li>a &gt; b，当且仅当G中含有形如P→…Rb…的产生式， 而 R⇒…a 或 R⇒…aQ</li></ul><p>示例：</p><p><img src="%E7%AC%AC10%E8%AE%B2.assets%5Cimage-20200320162434040.png" alt="image-20200320162434040"></p><h5 id="优先关系表"><a href="#优先关系表" class="headerlink" title="优先关系表"></a>优先关系表</h5><p><img src="%E7%AC%AC10%E8%AE%B2.assets%5Cimage-20200320163521525.png" alt="image-20200320163521525"></p><p>第一列表示处于左边的符号，第一行表示处于右边的符号</p><h2 id="构造优先关系表"><a href="#构造优先关系表" class="headerlink" title="构造优先关系表"></a>构造优先关系表</h2><h4 id="FIRSTVT和LASTVT集合"><a href="#FIRSTVT和LASTVT集合" class="headerlink" title="FIRSTVT和LASTVT集合"></a>FIRSTVT和LASTVT集合</h4><p>$$<br>FIRSVT(P) = {a | P \Rightarrow a … 或 P \Rightarrow Qa …, a \in V_T且Q \in V_N }<br>$$</p><p>P 推出的串里，从左至右第一个终结符<br>$$<br>LASTVT(P) = {a | P \Rightarrow … a 或 P \Rightarrow … aQ, a \in V_T且Q \in V_N }<br>$$<br>P 推出的串里，最后出现的终结符</p><h5 id="构造优先关系表的算法"><a href="#构造优先关系表的算法" class="headerlink" title="构造优先关系表的算法"></a>构造优先关系表的算法</h5><p>根据FIRSTVT和LASTVT集合，检查每个产生式的候选式，确定满足关系 &lt; 和 &gt; 的所有终结符对</p><ul><li>假定有个产生式的一个候选形为 … aP…， 那么，对任何 $$b \in FIRSTVT( P )$$，有 a &lt; b</li><li>假定有个产生式的一个候选形为… Pb…， 那么，对任何 $$a \in LASTVT(P)$$，有 a &gt; b</li></ul><h5 id="构造集合FIRSTVT-P-的算法"><a href="#构造集合FIRSTVT-P-的算法" class="headerlink" title="构造集合FIRSTVT(P)的算法"></a>构造集合FIRSTVT(P)的算法</h5><p>反复使用下面两条规则构造集合FIRSTVT(P)：</p><ul><li>若有产生式P→a … 或P→Qa…，则 $$a \in FIRSTVT(P)$$</li><li>若$$a \in FIRSTVT(Q)$$，且有产生式P→Q…，则$$a \in FIRSTVT(P)$$</li></ul><p>算法的一种实现</p><ul><li><strong>布尔数组F[P，a]</strong>，使得F[P，a]为真的条件是，当且仅当$$a \in FIRSTVT(P)$$。开始时，按上述的规则1对每个数组元素F[P，a]赋初值</li><li><strong>栈STACK</strong>，把所有初值为真的数组元素F[P，a]的符号对(P，a)全都放在STACK之中<ul><li>若栈STACK不空，就将栈顶项弹出，记此项为 (Q，a )。对于每个形如 P → Q…的产生式，若F[ P，a]为假，则变其值为真且将( P，a)推进STACK栈</li><li>上述过程一直重复，直至栈STACK为空为止</li></ul></li></ul><p><img src="%E7%AC%AC10%E8%AE%B2.assets%5Cimage-20200320183952479.png" alt="image-20200320183952479"></p><p>主程序中黑色代码为初始化，蓝色为使用规则1，红色使用规则2</p><p>直至栈为空，构造集合完毕</p><h5 id="构造集合LASTVT-P-的算法"><a href="#构造集合LASTVT-P-的算法" class="headerlink" title="构造集合LASTVT(P)的算法"></a>构造集合LASTVT(P)的算法</h5><p>反复使用下面两条规则构造集合LASTVT(P)：</p><ul><li>若有产生式P→… a 或P→…aQ，则 $$a \in LASTVT(P)$$</li><li>若$$a \in LASTVT(Q)$$，且有产生式P→…Q，则$$a \in LASTVT(P)$$</li></ul><h4 id="FIRSTVT和LASTVT集合计算示例"><a href="#FIRSTVT和LASTVT集合计算示例" class="headerlink" title="FIRSTVT和LASTVT集合计算示例"></a>FIRSTVT和LASTVT集合计算示例</h4><p><img src="%E7%AC%AC10%E8%AE%B2.assets%5Cimage-20200320211918714.png" alt="image-20200320211918714"></p><p><img src="%E7%AC%AC10%E8%AE%B2.assets%5Cimage-20200320211927263.png" alt="image-20200320211927263"></p><p>反复扫描，直到矩阵不再变化</p><h4 id="构造优先关系表的算法-1"><a href="#构造优先关系表的算法-1" class="headerlink" title="构造优先关系表的算法"></a>构造优先关系表的算法</h4><ul><li>通过检查G的每个产生式的每个候选式，可找出所有满足a = b的终结符对</li><li>根据FIRSTVT和LASTVT集合，检查每个产生式的候选式，确定满足关系 &lt; 和 &gt; 的所有终结符对<ul><li>假定有个产生式的一个候选形为 … aP…， 那么，对任何 $$b \in FIRSTVT( P )$$，有 a &lt; b</li><li>假定有个产生式的一个候选形为… Pb…， 那么，对任何 $$a \in LASTVT(P)$$，有 a &gt; b</li></ul></li></ul><p><img src="%E7%AC%AC10%E8%AE%B2.assets%5Cimage-20200320213055462.png" alt="image-20200320213055462"></p><h4 id="构造优先关系表示例"><a href="#构造优先关系表示例" class="headerlink" title="构造优先关系表示例"></a>构造优先关系表示例</h4><p><img src="%E7%AC%AC10%E8%AE%B2.assets%5Cimage-20200320225137037.png" alt="image-20200320225137037"></p><p>考虑<strong>#E#</strong>可以完成最后一列的判断</p><h2 id="算符优先分析算法"><a href="#算符优先分析算法" class="headerlink" title="算符优先分析算法"></a>算符优先分析算法</h2><h4 id="最左素短语"><a href="#最左素短语" class="headerlink" title="最左素短语"></a>最左素短语</h4><p>一个文法G的句型的<strong>素短语</strong>是指这样一个短语， 它至少含有<strong>一个终结符</strong>，并且，除它自身之外不再含任何更小的素短语</p><p><strong>终结符或是算符的优先关系是基于终结符进行比较的，因此，定义至少含有一个终结符的短语以便进行算符的比较</strong></p><p><strong>最左素短语</strong>是指处于句型最左边的那个素短语</p><p><img src="%E7%AC%AC10%E8%AE%B2.assets%5Cimage-20200320225856298.png" alt="image-20200320225856298"></p><h4 id="最左素短语定理"><a href="#最左素短语定理" class="headerlink" title="最左素短语定理"></a>最左素短语定理</h4><p>算符优先文法句型(括在两个＃之间)的一般形式：<br>$$<br>#N_1a_1N_2a_2…N_na_nN_{n+1}) #<br>$$<br>其中，a<del>i</del>都是终结符，N<del>i</del>是可有可无的非终结符(<strong>算符文法不能连续出现两个非终结符，但是可以连续出现多个终结符</strong>)</p><p><strong>定理：一个算符优先文法G的任何句型的最左素短语是满足如下条件的最左子串 N<del>j</del>a<del>j</del>…N<del>i</del> a<del>i</del>N<del>i+1</del></strong></p><p><img src="%E7%AC%AC10%E8%AE%B2.assets%5Cimage-20200320230927888.png" alt="image-20200320230927888"></p><p><strong>内部终结符的优先级相等，都大于外部的终结符</strong></p><h4 id="算符优先分析算法描述"><a href="#算符优先分析算法描述" class="headerlink" title="算符优先分析算法描述"></a>算符优先分析算法描述</h4><ul><li>使用一个符号栈S，用它寄存终结符和非终结符，k代表符号栈S的使用深度</li><li>在正确的情况下，算法工作完毕时，符号栈S应呈现：# N #</li></ul><p><img src="%E7%AC%AC10%E8%AE%B2.assets%5Cimage-20200320231345790.png" alt="image-20200320231345790"></p><p>黑色部分代码将j指向栈中<strong>最上面的终结符</strong></p><p>蓝色部分判断S[j]与输入的终结符符a的优先级，若a的优先级大于或等于S[j]，则a入栈，优先进行归约，若连续输入a的优先级一直大于等于S[j]，则一直读入终结符，<strong>直到a的优先级小于S[j]</strong>（此时栈顶即最左素短语的尾部）</p><p>执行红色部分代码，紫色部分是扫描寻找最左素短语的头部（栈上面的终结符优先级比下面的终结符高）</p><p>找到一个最左素短语后，进行归约，归约规则如下：</p><p>从左至右，<strong>终结符与终结符要对应相等</strong>，非终结符可以不完全对应（只要是非终结符就行，可忽略）</p><p><img src="%E7%AC%AC10%E8%AE%B2.assets%5Cimage-20200320231359559.png" alt="image-20200320231359559"></p><p>按照以上方法分析出来的分析树与语法树不同，分析树可能会简单一些，但是二者都表达了文法的结构</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Travis的hexo自动部署</title>
      <link href="/2020/05/07/ji-yu-travis-de-hexo-zi-dong-bu-shu/"/>
      <url>/2020/05/07/ji-yu-travis-de-hexo-zi-dong-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>首先需要能够正常部署hexo到github，这个有许多的教程，hexo的官方文档就够用了。</p><p>弄 <code>Travis CI</code> 持续集成就是为了方便写东西，在哪儿都能写，自动部署好，同时也想借这个机会了解一下 <code>Travis</code> 的持续集成是咋样的。</p><h2 id="Travis-CI-是什么"><a href="#Travis-CI-是什么" class="headerlink" title="Travis CI 是什么"></a><code>Travis CI</code> 是什么</h2><p><code>Travis CI</code> 提供的是持续集成（Continuous Integration）服务，它可以绑定github上的项目，只要有新的 <code>commit</code>，就会自动检测到新变化，提供一个虚拟的运行环境（一次性，每次都会重新创建环境进行构建），根据用户的配置文件 <code>.travis.yml</code> 在虚拟机中创建指定的运行环境，执行用户定义的所有命令及构建规则，并运行测试，若通过，也会按照用户定义的规则将新代码集成到主干上。</p><h4 id="tavis-yml"><a href="#tavis-yml" class="headerlink" title=".tavis.yml"></a><code>.tavis.yml</code></h4><p><code>Travis CI</code> 要求项目的根目录里，必须有一个 <code>.travis.yml</code> 文件。这个文件指定了 <code>Travis</code> 的行为。一旦仓库有了新的 <code>commit</code>，就会根据用户定义的工作流程执行相应的命令。</p><p><code>Travis</code> 默认提供的运行环境，参考<a href="https://docs.travis-ci.com/user/languages" target="_blank" rel="noopener">可运行语言</a>。部署方式参考<a href="https://docs.travis-ci.com/user/deployment/" target="_blank" rel="noopener">Deployment</a>。</p><p>更详细的文件配置查看官方教程<a href="https://docs.travis-ci.com/user/tutorial/" target="_blank" rel="noopener">travis tutorial</a></p><h4 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h4><p>任何项目都会经过两个阶段：</p><ul><li><code>install</code>: 安装依赖</li><li><code>script</code>: 运行脚本</li></ul><h5 id="install-字段"><a href="#install-字段" class="headerlink" title="install 字段"></a><code>install</code> 字段</h5><p><code>install</code> 用来指定安装脚本</p><pre class="line-numbers language-yml"><code class="language-yml">install: ./install.sh# 如果有多个脚本，写成如下的形式install:  - command1  - command2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中，如果 <code>command1</code> 失败了，整个构建就会停下来，不再往下进行。</p><p>如果不需要安装，即跳过安装阶段，就直接设为 <code>true</code>。</p><pre class="line-numbers language-yml"><code class="language-yml">install: true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="script-字段"><a href="#script-字段" class="headerlink" title="script 字段"></a><code>script</code> 字段</h5><p><code>script</code> 用来指定构建的命令及运行的脚本，包含测试脚本。</p><pre class="line-numbers language-yml"><code class="language-yml">script: bundle exec thor build# 如果有多个脚本，写成如下的形式install:  - command1  - command2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意，<code>script</code> 与 <code>install</code> 字段不一样，如果 <code>command1</code> 失败 ，<code>command2</code> 会继续执行。但是整个构建阶段的状态依然是失败。</strong></p><p>如果想让命令顺序执行，则要写成如下形式：</p><pre class="line-numbers language-yml"><code class="language-yml">script: command1 && command2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="deploy-字段"><a href="#deploy-字段" class="headerlink" title="deploy 字段"></a><code>deploy</code> 字段</h5><p><code>script</code> 阶段结束后，可以设置<a href="https://docs.travis-ci.com/user/notifications/" target="_blank" rel="noopener">通知步骤</a>和<a href="https://docs.travis-ci.com/user/deployment/" target="_blank" rel="noopener">部署</a>，但并不是必须的。</p><p>部署的脚本可以在 <code>script</code> 阶段执行，也可以使用 Travis 为几十种常见服务提供的快捷部署功能。比如部署到 <code>github pages</code>，可以使用 <code>provider: pages</code> 字段：</p><pre class="line-numbers language-yml"><code class="language-yml">deploy:  provider: pages  skip_cleanup: true  github_token: $GITHUB_TOKEN # Set in travis-ci.org dashboard  on:    branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多的部署方式，可以查看<a href="https://docs.travis-ci.com/user/deployment/" target="_blank" rel="noopener">官方Deplyment文档</a>。</p><h5 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h5><p>Travis 为上面这些阶段提供了7个钩子：</p><ul><li><code>before_install</code>: install 阶段之前执行</li><li><code>before_script</code>: script 阶段之前执行</li><li><code>after_failure</code>: script 阶段失败时执行</li><li><code>after_success</code>: script 阶段成功时执行</li><li><code>before_deploy</code>: deploy 步骤之前执行</li><li><code>after_deploy</code>: deploy 步骤之后执行</li><li><code>after_script</code>: script 阶段之后执行</li></ul><p>完整的生命周期，从开始到结束是下面的流程：</p><ol><li><code>before_install</code></li><li><code>install</code></li><li><code>before_script</code></li><li><code>script</code></li><li><code>aftersuccess or afterfailure</code></li><li><code>[OPTIONAL] before_deploy</code></li><li><code>[OPTIONAL] deploy</code></li><li><code>[OPTIONAL] after_deploy</code></li><li><code>after_script</code></li></ol><h5 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h5><p>Travis 每次运行，可能会返回四种状态：</p><ul><li><code>passed</code>: 运行成功，所有步骤的退出码都是0</li><li><code>canceled</code>: 用户取消执行</li><li><code>errored</code>: <code>before_install</code>、<code>install</code>、<code>before_script</code> 有非零退出码，运行会立即停止</li><li><code>failed</code>: <code>script</code> 有非零状态码 ，会继续运行</li></ul><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><h4 id="设置-Travis-CI-的仓库访问权限"><a href="#设置-Travis-CI-的仓库访问权限" class="headerlink" title="设置 Travis CI 的仓库访问权限"></a>设置 <code>Travis CI</code> 的仓库访问权限</h4><p>使用github账号登录 <code>Travis CI</code>，此时会让你在github中安装 <code>Travis CI</code>， 进入github，一步步打开 <code>profile_image -&gt; settings -&gt; Applications</code>，在此处可以看到应用，安装并配置仓库的权限，我给的权限是 <code>All repositories</code>，使其可以访问所有的仓库。</p><p><img src="https://raw.githubusercontent.com/daily-record/daily-record-img/master/20200507222016.png" alt=""></p><p><img src="https://raw.githubusercontent.com/daily-record/daily-record-img/master/20200507222120.png" alt=""></p><p>这时 Travis 当中就可以访问所有的仓库了，不过这时它只能访问仓库，还需要进一步配置才能完成自动化部署。</p><h4 id="Travis-CI-环境变量"><a href="#Travis-CI-环境变量" class="headerlink" title="Travis CI 环境变量"></a><code>Travis CI</code> 环境变量</h4><p>在 <code>Travis</code> 中可以通过设置环境变量来传递一些不便于写在配置文件中的值（如密码、密钥之类的）。</p><p>由于构建环境需要对应仓库的权限，所以要使用 <code>GitHub Personal Access Token</code>，在命令行中执行git操作用其代替密码（当然，也可以使用密码，只不过更改密码后 <code>Travis CI</code> 无法完成自动构建任务），可以在github中获取 <code>token</code> 并将其作为变量存入 <code>Travis CI</code> 中，这样就可以直接在配置文件中调用此变量进行使用，由于只有 <code>Travis CI</code> 有变量的值，所以安全性还是有保障的。</p><h5 id="获取-GitHub-Personal-Access-Token"><a href="#获取-GitHub-Personal-Access-Token" class="headerlink" title="获取 GitHub Personal Access Token"></a>获取 <code>GitHub Personal Access Token</code></h5><p>一步步打开 <code>profile_image -&gt; settings -&gt; Developer -&gt; Personal Access Token</code>，生成一个新的 <code>token</code>。由于只需对仓库进行push操作，所以仅把勾上 <code>repo</code> 部分勾上。</p><p><img src="https://raw.githubusercontent.com/daily-record/daily-record-img/master/20200508004800.png" alt=""></p><p>生成的 <code>token</code> 只显示一次，所以要及时保存下来。</p><h5 id="设置-Travis-CI-环境变量"><a href="#设置-Travis-CI-环境变量" class="headerlink" title="设置 Travis CI 环境变量"></a>设置 <code>Travis CI</code> 环境变量</h5><p>打开 <code>Travis CI</code>，进入需要操作的 <code>repo</code> 的settings，添加一个环境变量 <code>GITHUB_TOKEN</code>，将上一步骤中的 <code>token</code> 填入，<code>Branch</code> 选择需要进行构建的源代码分支（All branches也可）。</p><p><img src="https://raw.githubusercontent.com/daily-record/daily-record-img/master/20200508005556.png" alt=""></p><h4 id="配置-travis-yml-文件"><a href="#配置-travis-yml-文件" class="headerlink" title="配置 .travis.yml 文件"></a>配置 <code>.travis.yml</code> 文件</h4><p>在上面所有操作过后，最后剩下的就是利用配置文件指定 Travis 的行为。</p><h5 id="写入部署环境"><a href="#写入部署环境" class="headerlink" title="写入部署环境"></a>写入部署环境</h5><p>指定需要使用的语言及对应的版本。</p><pre class="line-numbers language-yml"><code class="language-yml">sudo: falselanguage: node_jsnode_js:  - 12 # use nodejs v12 LTS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="缓存-node-modules-目录"><a href="#缓存-node-modules-目录" class="headerlink" title="缓存 node_modules 目录"></a>缓存 <code>node_modules</code> 目录</h5><p><code>node_modules</code> 里包含了很多模块，每次重新下载安装花费大量时间，于是缓存这个目录。</p><pre class="line-numbers language-yml"><code class="language-yml">cache:  directories:    - node_modules<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="指定操作的分支"><a href="#指定操作的分支" class="headerlink" title="指定操作的分支"></a>指定操作的分支</h5><p>由于repo的 <code>master</code> 分支只能放hexo生成的静态文件(public文件夹)，所以需要将hexo的源目录丢在其它分支上，我使用 <code>hexo</code> 分支存储这些文件，所以只需要让 Traviss 检测 <code>hexo</code> 分支的变动就行。</p><pre class="line-numbers language-yml"><code class="language-yml"># assign build branchesbranches:  only:    - hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><p>这个按照hexo生成的顺序写入命令即可，可以在 Travis 的虚拟环境中正常生成所有静态文件</p><pre class="line-numbers language-yml"><code class="language-yml">before_install:  - npm install -g hexo-server  - npm install -g hexo-cli # install hexo  - npm install -g hexo  - npm install hexo-deployer-git --saveinstall:  - npm install script:  - hexo generate # generate static files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h5><p>使用 Travis 提供的快捷部署，这样就不需要自己写入各种git命令push到仓库中。</p><p>详细配置参考官方<a href="https://docs.travis-ci.com/user/deployment/pages/" target="_blank" rel="noopener">GitHub Pages Deployment</a>。</p><p>以下参数大概的意思就是使用github的快捷部署，将生成的文件夹 <code>local-dir: public</code> push到github的 <code>target_branch: master</code> 分支。</p><pre class="line-numbers language-yml"><code class="language-yml">deploy:  provider: pages  skip-cleanup: true  github-token: $GITHUB_TOKEN  keep-history: true  on:  #   branch: master    all_branches: true # solve a permission problem  target_branch: master  local-dir: public # Directory to push to GitHub Pages, defaults to current directory.                    # Can be specified as an absolute path or a relative path from the current directory.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="完整配置文件"><a href="#完整配置文件" class="headerlink" title="完整配置文件"></a>完整配置文件</h4><pre class="line-numbers language-yml"><code class="language-yml">sudo: falselanguage: node_jsnode_js:  - 12 # use nodejs v12 LTScache:  directories:    - node_modules# assign build branchesbranches:  only:    - hexobefore_install:  - npm install -g hexo-server  - npm install -g hexo-cli # install hexo  - npm install -g hexo  - npm install hexo-deployer-git --saveinstall:  - npm installscript:  - hexo generate # generate static filesdeploy:  provider: pages  skip-cleanup: true  github-token: $GITHUB_TOKEN  keep-history: true  on:  #   branch: master    all_branches: true # solve a permission problem  target_branch: master  local-dir: public # Directory to push to GitHub Pages, defaults to current directory.                    # Can be specified as an absolute path or a relative path from the current directory.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
            <tag> Travis </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps与CI/CD</title>
      <link href="/2020/03/31/devops-yu-ci-cd/"/>
      <url>/2020/03/31/devops-yu-ci-cd/</url>
      
        <content type="html"><![CDATA[<h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p>DevOps 一词的来自于 Development 和 Operations 的组合，突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、发布更加快捷、频繁和可靠</p></blockquote><p>DevOps 其实包含了三个部分:</p><ul><li>开发</li><li>测试</li><li>运维</li></ul><p>一个团队中各个角色存在天然上的工作矛盾：<br><img src="https://raw.githubusercontent.com/daily-record/daily-record-img/master/20200331144227.png" alt=""></p><p>对于运维来说，稳定性压到一切，新feature越少越好；而对于研发来说，能够开发的新功能越多越好，这种矛盾会导致大量资源的浪费。</p><p>DevOps 希望将产品交付过程中各种壁垒打破，让Dev和Ops一体化，通过自动化工具辅助开发完成运维的部分工作，减少成本。</p></br><h4 id="概述工作流"><a href="#概述工作流" class="headerlink" title="概述工作流"></a>概述工作流</h4><h5 id="传统工作流"><a href="#传统工作流" class="headerlink" title="传统工作流"></a>传统工作流</h5><p>PD(Demond) -&gt; [DEV(Coding) -&gt; SCM(Build) -&gt; QA(Test) -&gt; OPS(Deploy)]-&gt; Release<br>PD 提出需求 -&gt; [开发者根据需求写代码 -&gt; SCM 拿着代码去打包 -&gt; QA 测试 -&gt; 运维进行上线部署]</p></br><h4 id="DevOps工作流"><a href="#DevOps工作流" class="headerlink" title="DevOps工作流"></a>DevOps工作流</h4><p>通过高度自动化工具与流程来使得软件构建、测试、发布更加快捷、频繁和可靠；</p><p>同时，<code>CI/CD</code>（持续集成/持续部署）可看作传统工作流的增强版；<code>DevOps</code> 可看作是 <code>CI/CD</code> 的增强版。</p><p><img src="https://raw.githubusercontent.com/daily-record/daily-record-img/master/20200331150116.png" alt=""></p><p><img src="https://raw.githubusercontent.com/daily-record/daily-record-img/master/20200331150144.png" alt=""></p></br><h2 id="CI与CD"><a href="#CI与CD" class="headerlink" title="CI与CD"></a>CI与CD</h2><p>CI/CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI/CD 的核心概念是持续集成、持续交付和持续部署。</p><p>不过，由于还需要编写自动化测试以适应 CI/CD 管道中的各种测试和发布阶段，因此前期投资还是会很大。</p><ul><li>CI:持续集成(Continuous Integration)</li><li>CD:<ul><li>持续交付(Continuous Delivery)</li><li>持续部署(Continuous Deployment)</li></ul></li></ul></br><h4 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h4><p><strong>持续集成指的是，频繁地（一天多次）将代码集成到主干。</strong></p><p>持续集成可以帮助开发人员更加频繁地（有时甚至每天）将代码更改合并到共享分支或“主干”中。一旦开发人员对应用所做的更改被合并，系统就会通过自动构建应用并运行不同级别的自动化测试（通常是单元测试和集成测试）来验证这些更改，确保这些更改没有对应用造成破坏。这意味着测试内容涵盖了从类和函数到构成整个应用的不同模块。如果自动化测试发现新代码和现有代码之间存在冲突，CI 可以更加轻松地快速修复这些错误。</p></br><h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><p><strong>让产品可以快速迭代，同时还能保持高质量。</strong>它的核心措施是，代码集成到主干之前，<strong>必须通过自动化测试</strong>。只要有一个测试用例失败，就不能集成。</p></br><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><ol><li><strong>快速发现错误。</strong>每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。</li><li><strong>防止分支大幅偏离主干。</strong>如果不是经常集成，主干又在不断更新，会导致以后集成的难度会非常的大，甚至难以集成。</li></ol><blockquote><p>持续集成并不能消除Bug，而是让它们非常容易发现和改正。</p></blockquote></br><h4 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h4><p><strong>持续交付指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。</strong>如果评审通过，代码就进入生产阶段。</p><p>在持续交付中，每个阶段（从代码更改的合并，到生产就绪型构建版本的交付）都涉及测试自动化和代码发布自动化。在流程结束时，运维团队可以快速、轻松地将应用部署到生产环境中。</p><p>持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p></br><h4 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h4><p><strong>持续部署是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。</strong></p><p>持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</p><p>持续部署的前提是能自动化完成测试、构建、部署等步骤。</p><p>持续部署意味着开发人员对应用的更改在编写后的几分钟内就能生效（假设它通过了自动化测试）。这更加便于持续接收和整合用户反馈。总而言之，所有这些 CI/CD 的关联步骤都有助于降低应用的部署风险，因此更便于以小件的方式（而非一次性）发布对应用的更改。</p></br><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h4 id="DevOps工具链"><a href="#DevOps工具链" class="headerlink" title="DevOps工具链"></a>DevOps工具链</h4><p><img src="https://raw.githubusercontent.com/daily-record/daily-record-img/master/20200331175003.png" alt=""></p><ul><li>版本控制&amp;协作开发：GitHub、GitLab、BitBucket、SubVersion、Coding、Bazaar</li><li>自动化构建和测试: Apache Ant、Maven 、Selenium、PyUnit、QUnit、JMeter、Gradle、PHPUnit</li><li>持续集成&amp;交付:Jenkins、Capistrano、BuildBot、Fabric、Tinderbox、Travis CI、flow.ci Continuum、LuntBuild、CruiseControl、Integrity、Gump、Go</li><li>容器平台: Docker、Rocket、Ubuntu（LXC）、第三方厂商如（AWS/阿里云）</li><li>配置管理：Chef、Puppet、CFengine、Bash、Rudder、Powershell、RunDeck、Saltstack、Ansible</li><li>微服务平台：OpenShift、Cloud Foundry、Kubernetes、Mesosphere</li><li>服务开通：Puppet、Docker Swarm、Vagrant、Powershell、OpenStack Heat</li><li>日志管理：Logstash、CollectD、StatsD</li><li>监控，警告&amp;分析：Nagios、Ganglia、Sensu、zabbix、ICINGA、Graphite、Kibana</li></ul></br><h4 id="1-提交"><a href="#1-提交" class="headerlink" title="1. 提交"></a>1. 提交</h4><p>开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。</p></br><h4 id="2-测试（第一轮）"><a href="#2-测试（第一轮）" class="headerlink" title="2. 测试（第一轮）"></a>2. 测试（第一轮）</h4><p>代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。</p><p>测试分为多钟：</p><ul><li>单元测试：针对函数或模块的测试</li><li>集成测试：针对整体产品的某个功能的测试，又称功能测试</li><li>端对端测试：从用户界面直达数据库的全链路测试</li></ul><p>第一轮至少要跑单元测试。</p></br><h4 id="3-构建"><a href="#3-构建" class="headerlink" title="3. 构建"></a>3. 构建</h4><p>通过第一轮测试，代码就可以合并进主干，就算可以交付了。</p><p>交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。</p><p>常用的构建工具如下：</p><ul><li>Jenkins</li><li>Travis</li><li>Codeship</li><li>Strider</li></ul></br><h4 id="4-测试（第二轮）"><a href="#4-测试（第二轮）" class="headerlink" title="4. 测试（第二轮）"></a>4. 测试（第二轮）</h4><p>构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。</p><p>第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。</p><p>需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。</p></br><h4 id="5-部署"><a href="#5-部署" class="headerlink" title="5. 部署"></a>5. 部署</h4><p>通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。</p><p>生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。这方面的部署工具有Ansible，Chef，Puppet等。</p></br><h4 id="6-回滚"><a href="#6-回滚" class="headerlink" title="6. 回滚"></a>6. 回滚</h4><p>一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。</p></br><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">阮一峰：持续集成是什么</a></p><p><a href="https://marlous.github.io/2018/10/31/DevOps%20%E4%B8%8E%20CICD%20%E7%9A%84%E6%A6%82%E5%BF%B5/#%E4%B8%89-DevOps-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1" target="_blank" rel="noopener">DevOps工作流</a></p><p><a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd" target="_blank" rel="noopener">RedHat：什么是CI/CD</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> CI </tag>
            
            <tag> CD </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
