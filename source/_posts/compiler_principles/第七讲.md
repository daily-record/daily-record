# 语法分析-自上而下分析1



## 自上而下分析的基本问题



#### 语法分析的任务

- 分析一个文法的句子结构



#### 语法分析器的功能

- 按照文法的产生式（语言的语法规则），识别输入符号串是否为一个句子（合式程序）



#### 语法分析器在编译器中的地位

![image-20200315165955316](F:\learning\note\编译原理\第七讲.assets\image-20200315165955316.png)



#### 语法分析的方法

##### 自下而上（Bottom-up）

- 从输入串开始，逐步进行归约，直到文法的开始符号

- 根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号

- 从**树叶节点**开始，构造语法树

- 算符优先分析法、LR分析法



##### 自上而下（Top-down）

- 从文法的开始符号出发， 反复使用各种产生式，寻找"匹配"的推导
- 推导：根据文法的产生式 规则，把串中出现的产生式的左部符号替换成右部
- 从树的根开始，构造语法树
- 递归下降分析法、预测分析程序





#### 自上而下分析面临的问题

![image-20200315211034207](F:\learning\note\编译原理\第七讲.assets\image-20200315211034207.png)

##### 回溯问题

- 分析过程中，当一个非终结符用某一个候选匹配成功时，这种匹配可能是暂时的
- 出错时，不得不“回溯”



##### 文法左递归问题

![image-20200315211439235](F:\learning\note\编译原理\第七讲.assets\image-20200315211439235.png)

- 一个文法是含有左递归的，如果存在非终结符P





## LL(1)文法-消除左递归



#### 消除直接左递归

左递归转换为右递归，使得处理的单词能够一直推进，直到最后的非终结符，相比于左递归，不会在一开始就出现无限递归的情况（导致后续单词无法解析）

- 假定P关于的全部产生式是

$$
p \to P\alpha_1 | P\alpha_2 | ... | P\alpha_m | \beta_1 | \beta_2 | ... | \beta_n
$$

(每个 α都不等于 ε，每个 β都不以P开头)

![image-20200315213315489](F:\learning\note\编译原理\第七讲.assets\image-20200315213315489.png)



例：

![image-20200315224604783](F:\learning\note\编译原理\第七讲.assets\image-20200315224604783.png)



#### 消除间接左递归

- 一个文法消除左递归的条件
    - 不含以 ε为右部的产生式
    - 不含回路 （P => P）



![image-20200316143951616](F:\learning\note\编译原理\第七讲.assets\image-20200316143951616.png)



#### 消除左递归的算法

![image-20200316152048032](F:\learning\note\编译原理\第七讲.assets\image-20200316152048032.png)



例：

![image-20200316152234717](F:\learning\note\编译原理\第七讲.assets\image-20200316152234717.png)

由于从S出发到达S'，S'出发还是到达S'，所以Q和R没用，定义时多余的，可以删除

![image-20200316152446994](F:\learning\note\编译原理\第七讲.assets\image-20200316152446994.png)



## LL(1)文法-消除回溯

**为了消除回溯必须保证：**

- 对文法的任何非终结符，当要它去匹配输入串时，能够根据它所面临的输入符号准确地指派它的一个候选去执行任务，并且此候选的工作结果应是确信无疑的

**对于当前读入的一个符号a，在非终结符A的所有候选当中，准确地指派一个候选，去扩展A，使得最后一定能够分析成功（句子分析成功或是读入的不是句子）**



#### FIRST集合

令G是一个不含左递归的文法，对G的所有非终结符的每个候选α定义它的终结首符集FIRST(α) 为： 
$$
FIRST(\alpha) = \{a | \alpha => a ... , a \in V_T\}
$$
如果非终结符A的所有候选首符集两两不相交，即A的任何两个不同候选α~i~和α~j~
$$
FIRST(\alpha_i) \cap FIRST(\alpha_j) = \empty
$$
当要求A匹配输入串时，A能根据它所面临的第一个输入符号a，准确地指派某一个候选去执行任务。这个候选就是那个终结首符集含a的α



例：

![image-20200316192005200](F:\learning\note\编译原理\第七讲.assets\image-20200316192005200.png)



##### 提取公共左因子

![image-20200316191229572](F:\learning\note\编译原理\第七讲.assets\image-20200316191229572.png)





#### FOLLOW集合

![image-20200316193550925](F:\learning\note\编译原理\第七讲.assets\image-20200316193550925.png)





## LL(1)文法



#### LL(1)文法条件

- 构造不带回溯的自上而下分析的文法条件
    1. 文法不含左递归
    
    2. 对于文法中每一个非终结符A的各个产生式的候选首符集两两不相交。即，若
    
      $$A \to \alpha_1 | \alpha_2 | \alpha_3 | ... | \alpha_n$$
        
      则 $$FIRST(\alpha_i) \cap FIRST(\alpha_j) = \empty$$
        
    
    3.  对文法中的每个非终结符A，若它存在某个候选首符集包含ε，则
    
      $$FIRST(\alpha_i) \cap FOLLOW(A) = \empty, i = 1, 2, ..., n$$

如果一个文法G满足以上条件，则称该文法G为**LL(1)**（第一个L指从左向右推导，第二个L指最左推导，1指每一步只向前查看一个符号）



#### LL(1)分析

1. 假设要用非终结符A进行匹配，面临的输入符号为a，A 的所有产生式为$$A\to\alpha_1|\alpha_2|...|\alpha_n$$
    - 若$$a\in FIRST(\alpha_i)$$，则指派α~i~执行匹配任务；
    - 若a不属于任何一个候选首符集，则
        - 若ε属于某个FIRST(α~i~)且 $$a\in FOLLOW(A)$$， 则让 A与ε自动匹配
        - 否则，a的出现是一种语法错误



## FIRST和FOLLOW集合的构造

#### FIRST集合的构造

![image-20200321222107014](F:\learning\note\编译原理\第七讲.assets\image-20200321222107014.png)

#### FOLLOW集合的构造

![image-20200321222132139](F:\learning\note\编译原理\第七讲.assets\image-20200321222132139.png)














