## 4.1 词法分析概述



#### 词法分析

- 词法分析器的设计

- 正规表达式与有限自动机

- 词法分析器的自动产生--LEX




##### 词法分析的任务

> 从左至右逐个字符地对源程序进行扫描，产生一个个单词符号

- 词法分析器(Lexical Analyzer)
    - 扫描器(Scanner)
    - 执行词法分析的程序



##### 词法分析器的功能

> 输入源程序，输出单词符号

- 单词符号种类
    - 基本字：如 begin，repeat，for， …
    - 标识符：用来表示各种名字，如变量名、数组名和过程名
    - 常数：各种类型的常数
    - 运算符：+，-，*，/， …
    - 界符：逗号、分号、括号和空白



##### 词法分析器的输出

- 输出的单词符号的表示形式（一个二元组）：**(单词种别，单词自身的值 )**
- 单词种别通常用整数编码表示
    - 若一个种别只有一个单词符号，则种别编码就代表该单词符号。假定基本字 、运算符和界符都是一符一种
    - 若一个种别有多个单词符号，则对于每个单词符号，给出种别编码和自身的值
        - 标识符单列一种；标识符自身的值表示成按机器字节划分的内部码
        - 常数按类型分种；常数的值则表示成标准的二进制形式

![image-20200305204957424](F:\learning\note\编译原理\第四讲.assets\image-20200305204957424.png)

![image-20200305205006022](F:\learning\note\编译原理\第四讲.assets\image-20200305205006022.png)



##### 词法分析器在编译器中的地位

![image-20200305213155855](F:\learning\note\编译原理\第四讲.assets\image-20200305213155855.png)

- 词法分析器和语法分析器都会在符号表中记录访问，修改编译过程各类信息
- 分模块相互调用提高了系统的利用率



## 4.2 词法分析器的设计



#### 词法分析器的结构

![image-20200305214422322](F:\learning\note\编译原理\第四讲.assets\image-20200305214422322.png)

1. 预处理子程序在扫描器的调用下，将源程序输入到输入缓冲区中，读入输入缓冲区的字符，进行文本的预处理

2. 进行预处理后，规范性更好的文本被送入扫描缓冲区中

3. 预处理子程序返回扫描器，扫描器继续从缓冲区中读取预处理后的文本，根据词法规则识别出单词的符号



##### 扫描缓冲区

> 两个半区互补使用，防止一个单词的扫描被打断

![image-20200305221130549](F:\learning\note\编译原理\第四讲.assets\image-20200305221130549.png)

**半区的长度就是一个单词所允许的最大长度**

某些语言规定标识符的长度不能超过某个t值，可以推断编译器的扫描缓冲区长度为2t



#### 超前搜索

![image-20200305233628880](F:\learning\note\编译原理\第四讲.assets\image-20200305233628880.png)



- 标识符识别

    - 字母开头的字母数字串，后跟界符或算符

- 常数识别

    - 识别出算术常数并将其转变为二进制内码表示

        - 5.EQ.M（测试5和变量是否相等）
        - 5.E08（5*10^8^的科学计数表示）

    - 算符和界符的识别

        - 把多字符组成的算符和界符拼合成一个单词符号

            `:=， **， .EQ. ， ++，--，>=`



##### 几点限制——不必使用超前搜索

- 所有基本字都是保留字;用户不能用它们作自己的标识符
- 基本字作为特殊的标识符来处理，使用保留字表
- 如果基本字、标识符和常数(或标号)之间没有确定的运算符或界符作间隔，则必须使用一个空白符作间隔
    - 如 `DO99K=1，10` 要写成 `DO 99 K=1，10`



#### 状态转换图

> 状态转换图是一张有限方向图

- 结点代表`状态`，用圆圈表示
- `状态`之间用箭弧连结，箭弧上的标记(字符)代表射出结状态下可能出现的输入`字符`或`字符类`（箭头上的标记表示输入此标记后状态转换）
- 一张转换图只包含`有限个状态`，其中有一个为`初态`， 至少要有一个`终态`（用双圈表示）

![image-20200305235938616](F:\learning\note\编译原理\第四讲.assets\image-20200305235938616.png)



> 状态转换图可用于识别(或接受)一定的字符串

- 若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于α，则称α被该状态转换图所识别(接受)（最后读入的字符不属于当前识别的字符串）

![image-20200306000755729](F:\learning\note\编译原理\第四讲.assets\image-20200306000755729.png)

**\*号表示最后面读入的字符不属于刚才读入的单词**

以下则是识别标识符的状态转换图：

![image-20200306001126007](F:\learning\note\编译原理\第四讲.assets\image-20200306001126007.png)





##### 词法分析器设计示例



![image-20200306111428825](F:\learning\note\编译原理\第四讲.assets\image-20200306111428825.png)

- 状态0识别单词前的空白符
- 0 -> 13 是出错处理



#### 状态转换图的实现

##### 不含回路的状态结点

- 可用一个`CASE`语句或一组`IF-THEN-ELSE`语句实现

![image-20200306113509712](F:\learning\note\编译原理\第四讲.assets\image-20200306113509712.png)



##### 含回路的状态结点

- 对应一段由`WHILE`结构和`IF`语句构成的程序

![image-20200306113537952](F:\learning\note\编译原理\第四讲.assets\image-20200306113537952.png)



##### 终态结点

- 表示识别出某种单词符号，对应返回语句

![image-20200306114751041](F:\learning\note\编译原理\第四讲.assets\image-20200306114751041.png)



##### 全局变量与过程



##### 词法分析器的实现

###### 识别标识符

![image-20200306120105948](F:\learning\note\编译原理\第四讲.assets\image-20200306120105948.png)

```c
int code, value; strToken := “ ”; /*置strToken为空串*/
GetChar();
GetBC(); //跳过空白
if (IsLetter())
begin 
    while (IsLetter() or IsDigit()) 
    begin 
        Concat(); // 如果为字母或数字则连接到strToken中
        GetChar();
	end
	Retract(); // 最后读入的字符回退回去
	code := Reserve();	// 拿strToken中的字符串查询保留字表，如果是保留字，返回种别编码，否则就是用户自定义的标识符，返回0
	if (code = 0) // 判断为用户自定义的标识符
	begin 
        value := InsertId(strToken); // 将其插入到符号表中并返回入口值
		return ($ID, value); // 返回种别编码及对应的入口值
	end
	else
		return (code, -); // 直接返回保留字的种别编码，无值
end
```



###### 识别整常数



![image-20200306120145223](F:\learning\note\编译原理\第四讲.assets\image-20200306120145223.png)

```c
else if (IsDigit())
begin
	while (IsDigit())
	begin
		Concat( );  // 如果为数字则连接到strToken中
		GetChar( );
	end
	Retract();	// 最后读入的字符回退回去
	value := InsertConst(strToken);
	return($INT, value);
end
else if (ch =‘=’) return ($ASSIGN, -);
else if (ch =‘+’) return ($PLUS, -);
```



###### 识别其它字符

![image-20200306120208499](F:\learning\note\编译原理\第四讲.assets\image-20200306120208499.png)



```c
else if (ch =‘*’)
begin
	GetChar();
	if (ch =‘*’) return ($POWER, -); // 乘方符号判断
	Retract(); return ($STAR, -);
end
else if (ch =‘,’) return ($COMMA, -);
else if (ch =‘(’) return ($LPAR, -);
else if (ch =‘)’) return ($RPAR, -);
else ProcError( ); /* 错误处理*/
```



##### 状态转换图的代码一般化

- 变量`curState`用于保存现有的状态

- 用二维数组表示状态图：`stateTrans[state][ch]`



```c
curState = 初态
GetChar();
while(stateTrans[curState][ch]有定义){
    //存在后继状态，读入、拼接
    Concat();
    //转换入下一状态，读入下一字符
    curState= stateTrans[curState][ch];
    if curState是终态 then 返回strToken中的单词
    GetChar();
}
```


