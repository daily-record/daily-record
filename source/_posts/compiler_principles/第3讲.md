## 3.1 上下文无关文法



#### 文法

> 描述语言的语法结构的形式规则

![image-20200303184741423](第3讲.assets\image-20200303184741423.png)



#### 语言描述的基本概念

- 字母表：一个有穷字符集，记为∑
- 字母表中每个元素称为字符
- ∑上的 字(也叫字符串) 是指由∑中的字符所构成 的一个有穷序列
- 不包含任何字符的序列称为空字，记为ε
- 用∑*表示∑上的所有字的全体，包含空字ε
- 例如: 设 ∑={a， b}，则 ∑*={ ε,a,b,aa,ab,ba,bb,aaa,...}



- ∑ *的子集 U 和 V 的连接 （ 积）定义为

$$
UV ＝\{ αβ \space | \space α∈U \space \& \space β∈V\}
$$



$$
U = \{ a, aa\}\\
    V = \{b, bb\}\\
    UV = \{ab, abb, aab, aabb\}
$$



$$
\begin{align*}
V^n &= VVVVV...V\\
V^0 &= \{ε\}\\
V^* 是V的闭包\space\space\space V^* &= V^0∪V^1∪V^2∪V^3∪…\\
V^+是V的正规闭包：V^＋ &＝ V V^*
\end{align*}
$$



#### 上下文无关文法



- 上下文无关文法G是一个四元组 ==G=(V ~T~，V~N~，S，P)== 

    - V~T~ ：终结符(Terminal)集合(非空)

    - V~N~：非终结符(Noterminal)集合(非空)，且V~T~ ∩ V~N~= ∅

    - S：文法的开始符号，S ∈ V~N~

    - P：产生式集合(有限)，每个产生式形式为
        $$
        P→α， P∈V_N， α ∈ (V_T∪V_N)*
        $$
        

**终结符在文法中是可以再分解与定义的**

![image-20200304173936242](第3讲.assets\image-20200304173936242.png)



![image-20200304174730515](第3讲.assets\image-20200304174730515.png)





## 3.2 文法与语言



#### 文法生成语言

##### 推导

> 定义：称αAβ直接推出αγβ，即 αAβ => αγβ
>
> 仅当A → γ是一个产生式，且α， β∈ (V~T~ ∪ V~N~)* 。

- 如果α~1~ => α~2~ => … =>α~n~，则我们称这个序列是从α~1~到α~n~的一个推导。若存在一个从α~1~到α~n~的推导，则称α~1~可以推导出α~n~
- 对文法G(E)： E → i | E+E | E*E | (E)：
    - E => (E) => (E+E) => (i+E) => (i+i) 



##### 句型、句子和语言

*假定 G是一个文法，S 是它的开始符号*

- 如果 𝑆∗ ⇒ 𝛼，则称 α是一个==句型==

- 仅含终结符号的句型是一个==句子==

- 文法G所产生的句子的全体是一个==语言==，记为 L(G)：
    $$
    L(G) = \{ α | S => α,  α ∈ V_T^*\}
    $$
    **α由终结符构成，并能够由文法的开始符号推出来**

    



##### 文法与语言



![image-20200304233248471](第3讲.assets\image-20200304233248471.png)

 

![image-20200304233734274](第3讲.assets\image-20200304233734274.png)





## 3.3 语法树与二义性

#### 最左推导和最右推导

> 从一个句型到另一个句型的推导往往不唯一

$$
E + E => i + E => i + i\\
E + E => E + i => i + i
$$

- **最左推导**：任何一步 α => β都是对 α中的最左非终结符进行替换
- **最右推导**：任何一步 α => β都是对 α中的最右非终结符进行替换



#### 语法树

> 用一张图表示一个句型的推导,称为语法树
>
> 以开始符号为根节点，不断增长，当用一条规则把一个非终结符号替换成其候选式时，就从该非终结符对应的结点乡下生长出一颗子树，这棵子树以候选的符号作为结点，随着推导的进行，最终这个树中所有叶结点从左到右排列起来就是要推导出的句型

**一棵语法树是不同推导过程的共性抽象**（最左推导与最右推导的语法树一样）



#### 语法树与二义性(ambiguity)

> 文法的二义性：如果一个文法存在某个句子对应两棵不同的语法树，则说这个文法是二义的 G(E)： E → i|E+E|E*E|(E) 是二义文法

> 语言的二义性：一个语言是二义的，如果对它不存在无二义的文法

- 对于语言L，可能存在G和G’，使得 L(G)=L(G’)=L，有可能其中一个文法为二义的， 另一个为无二义的（只要语言有一个无二义的文法，则这个语言不是二义的）



> 二义性问题是不可判定问题，即不存在一个算法，它能在有限步骤内，确切地判定一个文法是否是二义的

- 可以找到一组无二义文法的充分条件（不满足此条件的，有无二义性都是可能的）



## 3.4 形式语言鸟瞰



- 0型(短语文法，图灵机)
    - 产生式形如： α→β
    - 其中：α∈ (V~T~ ∪ V~N~)^*^且至少含有一个非终结符；β∈ (V~T~ ∪ V~N~)^*^
- 1型(上下文有关文法，线性界限自动机)
    - 产生式形如： α→β
    - 其中：|α| ≤ |β|，仅 S→ε 例外
- 2型(上下文无关文法，非确定下推自动机)
    - 产生式形如： A → β
    - 其中：A∈ V~N~；β∈ (V~T~ ∪ V~N~)
- 3型(正规文法，有限自动机)
    - 右线性文法
        - 产生式形如： A → αB 或 A → α
        - 其中： α∈ V~T~*；A，B∈V~N~
    - 左线性文法
        - 产生式形如： A → Bα 或 A → α
        - 其中： α∈ V~T~*；A，B∈V~N~

![image-20200305160533722](第3讲.assets\image-20200305160533722.png)



#### 上下文无关文法与上下文有关文法

- L~5~={a^n^ b^n^|n ≥1} 不能由正规文法产生，但可由上下文无关文法产生
    $$
    G_5(S)： S → aSb|ab
    $$
    
- L~6~={a^n^ b^n^ c^n^|n ≥1}不能由上下文无关文法产生，但可由上下文有关文法产生

$$
\begin{align*}
G_6(S):S &→ aSBC| aBC\\
CB &→ BC\\
aB &→ ab\\
bB &→ bb\\
bC &→ bc\\
cC &→ cc\\
\end{align*}
$$


$$
\begin{align*}S
&=> aSBC\\
&=> aaSBCBC\\
&=> aaaBCBCBC\\
&=> aaaBBCCBC\\
&=> aaaBBCBCC\\
&=> aaaBBBCCC\\
&=> aaabBBCCC\\
&=> aaabbBCCC\\
&=> aaabbbCCC\\
&=> aaabbbcCC\\
&=> aaabbbccC\\
&=> aaabbbccc
\end{align*}
$$


#### 程序设计语言的描述

- 程序设计语言不是上下文无关语言，甚至不是上下文有关语言
- L~7~={ αcα| α∈{a,b}* }不能由上下文无关文法产生， 甚至连上下文有关文法也不能产生，只能由 0 型文法产生
    - 标识符引用（先声明后使用）
    - 过程调用过程中，“形 - 实参数的对应性"（如个数，顺序和类型一致性）
- 对于现今程序设计语言，在编译程序中，仍然采用上下文无关文法来描述其语言结构，超出上下文无关/有关文法描述能力的那部分语言约束，可以合并到语义分析阶段去做（如检查标识符是否先声明后使用）

